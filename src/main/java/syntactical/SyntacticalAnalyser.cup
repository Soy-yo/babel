package syntactical;

import java_cup.runtime.*;
import lexical.LexicalAnalyser;
import lexical.LexicalUnit;
import syntactical.ast.*;
import error.SyntacticalException;

import java.util.*;

init with {::}
scan with {:
    return analyser.next_token();
:}
action code {::}
parser code {:
    private LexicalAnalyser analyser = (LexicalAnalyser) getScanner();
:}

terminal String IF, ELSE, SWITCH, FOR, WHILE, IN, RETURN, CONST, CLASS, CONSTRUCTOR, UNDERSCORE, PARENTH_L,
         PARENTH_R, SQUARE_L, SQUARE_R, CURLY_L, CURLY_R, ARROW, ELLIPSIS, POINT, COMMA, PLUS_ASSIGN, PLUS,
         MINUS_ASSIGN, MINUS, MULT_ASSIGN, MULT, DIV_ASSIGN, DIV, MOD_ASSIGN, MOD, LE, LT, GE, GT, IDENTITY, EQUALS,
         NEQ, ASSIGNMENT, NOT, AND, OR, END;
terminal String IDENTIFIER, GLOBAL, THIS, TYPE, IMPORT;
terminal String INT, REAL, CHAR, STRING, TRUE, FALSE, NOTHING, NULL;

// Program
nonterminal ProgramNode Program;
// Imports
nonterminal List<String> ImportList;
nonterminal String Import, FilePath, Filename;
// Declarations
nonterminal DeclarationNode DeclarationList, Declaration;
// Variables
nonterminal VarDeclarationNode VarDeclaration, GlobalVarConstDeclaration, VarConstDeclaration, VarInitDeclaration,
            GlobalConstDeclaration, LocalConstDeclaration;
nonterminal Name BaseVarDeclaration;
// Functions
nonterminal FunctionDeclarationNode FunctionDeclaration;
nonterminal List<Name> FunctionParameters, ParameterList;
// Classes
nonterminal ClassDeclarationNode ClassDeclaration;
nonterminal DeclarationNode ClassBlock, ClassElementList, ClassElement;
nonterminal ConstructorDeclarationNode ConstructorDeclaration;
// Statements
nonterminal StatementNode StatementList, Statement;
// Block
nonterminal BlockStatementNode BlockStatement;
// Declaration statements
nonterminal VarDeclarationStatementNode VarDeclarationStatement;
// Assignment
nonterminal AssignmentStatementNode AssignmentStatement;
// Function call
nonterminal FunctionCallStatementNode FunctionCallStatement;
// Return
nonterminal ReturnStatementNode ReturnStatement;
// Conditionals
nonterminal IfElseStatementNode IfElseStatement;
nonterminal StatementNode ElsePartStatement;
nonterminal SwitchStatementNode SwitchStatement;
nonterminal Map<ExpressionNode,StatementNode> SwitchCasesStatement;
// Loops
nonterminal WhileStatementNode WhileStatement;
nonterminal ForStatementNode ForStatement;
// Expressions
nonterminal ExpressionNode Expression;
nonterminal ExpressionNode Expression0;
nonterminal ExpressionNode Expression1;
nonterminal ExpressionNode Expression2;
nonterminal ExpressionNode Expression3;
nonterminal ExpressionNode Expression4;
nonterminal ExpressionNode Expression5;
nonterminal ExpressionNode Expression6;
nonterminal ExpressionNode Expression7;
nonterminal ExpressionNode Expression8, Expr8;
nonterminal ExpressionNode Expression9, Expr9;
nonterminal PointExpressionNode FieldAccessExpression;
nonterminal ArrayAccessExpressionNode ArrayAccessExpression;
nonterminal FunctionCallExpressionNode FunctionCallExpression, FunctionCallExpr;
// Constants
nonterminal VariableExpressionNode VariableExpression;
nonterminal ConstantExpressionNode ConstantExpression;
nonterminal ListConstructorExpressionNode ListConstructorExpression;
nonterminal List<ExpressionNode> ListElements;
nonterminal AnonymousObjectConstructorExpressionNode AnonymousObjectConstructorExpression;
nonterminal VarDeclarationNode AnonymousObjectFields, AnonymousObjectField;
nonterminal ConstructorCallExpressionNode ConstructorCallExpression;
// Other
nonterminal String TypeName;
nonterminal Type Type;
nonterminal Designator Designator;
nonterminal ExpressionNode ArrayAccess, FieldAccess, DesignableExpression;
nonterminal List<ExpressionNode> Arguments, ArgumentList;

// TODO fix Assignments and constructor conflicts

// Program
Program ::= ImportList: imports DeclarationList: declarations
            {: RESULT = new ProgramNode(declarations, imports); :};

// Imports
ImportList ::= ImportList: imports Import: file
               {: imports.add(file); RESULT = imports; :}
             |
               {: RESULT = new ArrayList<>(); :};
Import     ::= IMPORT FilePath: path END
               {: RESULT = path; :};
FilePath   ::= FilePath: path DIV Filename: filename
               {: RESULT = path + "/" + filename; :}
             | Filename: filename
               {: RESULT = filename; :};
Filename   ::= IDENTIFIER: name
               {: RESULT = name; :}
               | GLOBAL: name
               {: RESULT = name; :}
               | TYPE: name
               {: RESULT = name; :};

// Declarations
DeclarationList ::= Declaration: declaration DeclarationList: declarations
                    {: RESULT = declaration.linkedTo(declarations); :}
                  |
                    {: RESULT = null; :};
Declaration     ::= GlobalVarConstDeclaration: declaration
                    {: RESULT = declaration; :}
                  | FunctionDeclaration: declaration
                    {: RESULT = declaration; :}
                  | ClassDeclaration: declaration
                    {: RESULT = declaration; :};

// Variables
GlobalVarConstDeclaration ::= VarDeclaration: declaration
                              {: RESULT = declaration; :}
                            | GlobalConstDeclaration: declaration END
                              {: RESULT = declaration; :};
VarConstDeclaration       ::= VarDeclaration: declaration
                              {: RESULT = declaration; :}
                            | LocalConstDeclaration: declaration END
                              {: RESULT = declaration; :};
VarDeclaration            ::= BaseVarDeclaration: declaration END
                              {: RESULT = new VarDeclarationNode(declaration); :}
                            | VarInitDeclaration: declaration END
                              {: RESULT = declaration; :};
BaseVarDeclaration        ::= Type: type IDENTIFIER: id
                              {: RESULT = new Name(id, type); :};
VarInitDeclaration        ::= BaseVarDeclaration: name ASSIGNMENT Expression: initialValue
                              {: RESULT = new VarDeclarationNode(name, initialValue); :}
                            | ConstructorCallExpression: constructor IDENTIFIER: id
                              {: RESULT = VarDeclarationNode.fromConstructor(constructor, id); :};
GlobalConstDeclaration    ::= CONST Type: type GLOBAL: id ASSIGNMENT Expression: initialValue
                              {: RESULT = new VarDeclarationNode(new Name(id, type), initialValue, true); :}
                            | CONST ConstructorCallExpression: constructor GLOBAL: id
                              {: RESULT = VarDeclarationNode.fromConstructor(constructor, id).constant(); :};
LocalConstDeclaration     ::= CONST VarInitDeclaration: declaration
                              {: RESULT = declaration.constant(); :};

// Functions
FunctionDeclaration ::= BaseVarDeclaration: name FunctionParameters: parameters BlockStatement: block
                        {: RESULT = new FunctionDeclarationNode(name, parameters, block); :};
FunctionParameters  ::= PARENTH_L PARENTH_R
                        {: RESULT = new ArrayList<>(); :}
                      | PARENTH_L ParameterList: parameters PARENTH_R
                        {: RESULT = parameters; :};
ParameterList       ::= BaseVarDeclaration: parameter
                        {: RESULT = new ArrayList<>(Collections.singletonList(parameter)); :}
                      | ParameterList: parameters COMMA BaseVarDeclaration: parameter
                        {: parameters.add(parameter); RESULT = parameters; :};

// Classes
ClassDeclaration       ::= CLASS TypeName: name ClassBlock: block
                           {: RESULT = new ClassDeclarationNode(name, block); :};
ClassBlock             ::= CURLY_L ClassElementList: contents CURLY_R
                           {: RESULT = contents; :};
ClassElementList       ::= ClassElement: element ClassElementList: elements
                           {: RESULT = element.linkedTo(elements); :}
                         |
                           {: RESULT = null; :};
ClassElement           ::= VarConstDeclaration: declaration
                           {: RESULT = declaration; :}
                         | ConstructorDeclaration: declaration
                           {: RESULT = declaration; :}
                         | FunctionDeclaration: declaration
                           {: RESULT = declaration; :};
ConstructorDeclaration ::= CONSTRUCTOR FunctionParameters: parameters BlockStatement: block
                           {: RESULT = new ConstructorDeclarationNode(parameters, block); :};

// Statements
StatementList ::= Statement: statement StatementList: statements
                  {: RESULT = statement.linkedTo(statements); :}
                |
                  {: RESULT = null; :};
Statement     ::= VarDeclarationStatement: statement
                  {: RESULT = statement; :}
                | AssignmentStatement: statement
                  {: RESULT = statement; :}
                | FunctionCallStatement: statement
                  {: RESULT = statement; :}
                | ReturnStatement: statement
                  {: RESULT = statement; :}
                | IfElseStatement: statement
                  {: RESULT = statement; :}
                | SwitchStatement: statement
                  {: RESULT = statement; :}
                | WhileStatement: statement
                  {: RESULT = statement; :}
                | ForStatement: statement
                  {: RESULT = statement; :}
                | BlockStatement: statement
                  {: RESULT = statement; :};

// Block
BlockStatement ::= CURLY_L StatementList: root CURLY_R
                   {: RESULT = new BlockStatementNode(root); :};

// Declaration statements
VarDeclarationStatement ::= VarConstDeclaration: declaration
                            {: RESULT = declaration.asStatement(); :};

// Assignment
AssignmentStatement ::= Designator: designator ASSIGNMENT Expression: expression END
                        {: RESULT = new AssignmentStatementNode(designator, expression); :}
                      | Designator: designator PLUS_ASSIGN Expression: expression END
                        {: RESULT = AssignmentStatementNode.fromSyntacticSugar(designator, "_plus", expression); :}
                      | Designator: designator MINUS_ASSIGN Expression: expression END
                        {: RESULT = AssignmentStatementNode.fromSyntacticSugar(designator, "_minus", expression); :}
                      | Designator: designator MULT_ASSIGN Expression: expression END
                        {: RESULT = AssignmentStatementNode.fromSyntacticSugar(designator, "_mult", expression); :}
                      | Designator: designator DIV_ASSIGN Expression: expression END
                        {: RESULT = AssignmentStatementNode.fromSyntacticSugar(designator, "_div", expression); :}
                      | Designator: designator MOD_ASSIGN Expression: expression END
                        {: RESULT = AssignmentStatementNode.fromSyntacticSugar(designator, "_mod", expression); :};

// Function call
FunctionCallStatement ::= FunctionCallExpr: function END
                          {: RESULT = new FunctionCallStatementNode(function); :};

// Return
ReturnStatement ::= RETURN END
                    {: RESULT = new ReturnStatementNode(); :}
                  | RETURN Expression: expression END
                    {: RESULT = new ReturnStatementNode(expression); :};

// Conditionals
IfElseStatement   ::= IF Expression: condition BlockStatement: ifBlock ElsePartStatement: elsePart
                      {: RESULT = new IfElseStatementNode(condition, ifBlock, elsePart); :};
ElsePartStatement ::= ELSE BlockStatement: elseBlock
                      {: RESULT = elseBlock; :}
                    | ELSE IfElseStatement: ifElse
                      {: RESULT = ifElse; :}
                    |
                      {: RESULT = null; :};

SwitchStatement      ::= SWITCH Expression: expression CURLY_L SwitchCasesStatement: cases CURLY_R
                         {: RESULT = new SwitchStatementNode(expression, cases); :};
SwitchCasesStatement ::= ConstantExpression: expression ARROW Statement: statement
                         {: RESULT = new HashMap<>(Collections.singletonMap(expression, statement)); :}
                       | SwitchCasesStatement: cases Expression: expression ARROW Statement: statement
                         {: cases.put(expression, statement); RESULT = cases; :};

// Loops
WhileStatement ::= WHILE Expression: condition BlockStatement: whileBlock
                    {: RESULT = new WhileStatementNode(condition, whileBlock); :};

ForStatement ::= FOR BaseVarDeclaration: variable IN Expression: iterable BlockStatement: forBlock
                    {: RESULT = new ForStatementNode(variable, iterable, forBlock); :};


// Expressions
Expression ::= Expression0: expression
               {: RESULT = expression; :};

Expression9 ::= Expr9: expression
                {: RESULT = expression; :}
              | AnonymousObjectConstructorExpression: expression
                {: RESULT = expression; :};
Expression8 ::= FieldAccessExpression: expression
                {: RESULT = expression; :}
              | ArrayAccessExpression: expression
                {: RESULT = expression; :}
              | FunctionCallExpression: expression
                {: RESULT = expression; :}
              | Expression9: expression
                {: RESULT = expression; :};
Expression7 ::= PLUS: plus Expression7: first
                {: RESULT = FunctionCallExpressionNode.operator(_PLUS, first); :}
              | MINUS: minus Expression7: first
                {: RESULT = FunctionCallExpressionNode.operator(_MINUS, first); :}
              | NOT: not Expression7: first
                {: RESULT = FunctionCallExpressionNode.operator(_NOT, first); :}
              | Expression8: first
                {: RESULT = first; :};
Expression6 ::= Expression6: first MULT: mult Expression7: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _MULT, last); :}
              | Expression6: first DIV: div Expression7: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _DIV, last); :}
              | Expression6: first MOD: mod Expression7: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _MOD, last); :}
              | Expression7: first
                {: RESULT = first; :};
Expression5 ::= Expression5: first PLUS: plus Expression6: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _PLUS, last); :}
              | Expression5: first MINUS: minus Expression6: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _MINUS, last); :}
              | Expression6: first
                {: RESULT = first; :};
Expression4 ::= Expression4: first GT: gt Expression5: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _GT, last); :}
              | Expression4: first GE: ge Expression5: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _GE, last); :}
              | Expression4: first LT: lt Expression5: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _LT, last); :}
              | Expression4: first LE: le Expression5: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _LE, last); :}
              | Expression5: first
                {: RESULT = first; :};
Expression3 ::= Expression3: first EQUALS: equals Expression4: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _EQUALS, last); :}
              | Expression3: first NEQ: neq Expression4: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _NEQ, last); :}
              | Expression3: first IDENTITY: identity Expression4: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _ID, last); :}
              | Expression4: first
                {: RESULT = first; :};
Expression2 ::= Expression2: first AND: and Expression3: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _AND, last); :}
              | Expression3: first
                {: RESULT = first; :};
Expression1 ::= Expression1: first OR: or Expression2: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _OR, last); :}
              | Expression2: first
                {: RESULT = first; :};
Expression0 ::= Expression0: first ELLIPSIS: ellipsis Expression1: last
                {: RESULT = FunctionCallExpressionNode.operator(first, _TO, last); :}
              | Expression1: first
                {: RESULT = first; :};

ArrayAccessExpression  ::= Expression8: array SQUARE_L Expression: index SQUARE_R
                           {: RESULT = new ArrayAccessExpressionNode(array, index); :};
FieldAccessExpression  ::= Expression8: expression POINT IDENTIFIER: identifier
                           {: RESULT = new PointExpressionNode(expression, identifier); :};
FunctionCallExpression ::= Expression8: function Arguments: arguments
                           {: RESULT = new FunctionCallExpressionNode(function, arguments); :};

// Fix shift-reduce conflict between FunctionCallStatement and AnonymousObjectConstructorExpression
FunctionCallExpr ::= Expr8: function Arguments: arguments
                     {: RESULT = new FunctionCallExpressionNode(function, arguments); :};
Expr8             ::= Expr8: array SQUARE_L Expression: index SQUARE_R
                      {: RESULT = new ArrayAccessExpressionNode(array, index); :}
                    | Expr8: expression POINT IDENTIFIER: identifier
                      {: RESULT = new PointExpressionNode(expression, identifier); :}
                    | Expr9: expression
                      {: RESULT = expression; :};
Expr9             ::= PARENTH_L Expression0: expression PARENTH_R
                      {: RESULT = expression; :}
                    | VariableExpression: expression
                      {: RESULT = expression; :}
                    | ConstantExpression: expression
                      {: RESULT = expression; :}
                    | ListConstructorExpression: expression
                      {: RESULT = expression; :}
                    | ConstructorCallExpression: expression
                      {: RESULT = expression; :};

// Constants
VariableExpression ::= IDENTIFIER: id
                       {: RESULT = new VariableExpressionNode(id); :}
                     // TODO uncomment
                     //| GLOBAL: id
                     //  {: RESULT = new VariableExpressionNode(id); :}
                     | THIS: id
                       {: RESULT = new VariableExpressionNode(id); :};
ConstantExpression ::= INT: n
                       {: RESULT = ConstantExpressionNode.fromInt(n); :}
                     | REAL: x
                       {: RESULT = ConstantExpressionNode.fromFloat(x); :}
                     | TRUE: t
                       {: RESULT = ConstantExpressionNode.fromBoolean(t); :}
                     | FALSE: f
                       {: RESULT = ConstantExpressionNode.fromBoolean(f); :}
                     | CHAR: c
                       {: RESULT = ConstantExpressionNode.fromChar(c); :}
                     | NOTHING
                       {: RESULT = ConstantExpressionNode.ofNothing(); :}
                     | NULL
                       {: RESULT = ConstantExpressionNode.ofNull(); :}
                     | UNDERSCORE
                       {: RESULT = ConstantExpressionNode.ofNull(); :};

ListConstructorExpression ::= STRING: str
                              {: RESULT = ListConstructorExpressionNode.fromString(str); :}
                            | SQUARE_L SQUARE_R
                              {: RESULT = new ListConstructorExpressionNode(); :}
                            | SQUARE_L ListElements: elements SQUARE_R
                              {: RESULT = new ListConstructorExpressionNode(elements); :};
ListElements              ::= Expression: element
                              {: RESULT = new ArrayList<>(Collections.singletonList(element)); :}
                            | ListElements: elements COMMA Expression: element
                              {: elements.add(element); RESULT = elements; :};

AnonymousObjectConstructorExpression ::= CURLY_L CURLY_R
                                         {: RESULT = new AnonymousObjectConstructorExpressionNode(); :}
                                       | CURLY_L AnonymousObjectFields: fields CURLY_R
                                         {: RESULT = new AnonymousObjectConstructorExpressionNode(fields); :};
AnonymousObjectFields                ::= AnonymousObjectField: field
                                         {: RESULT = field; :}
                                       | AnonymousObjectField: field COMMA AnonymousObjectFields: fields
                                         {: field.linkedTo(fields); RESULT = field; :};
AnonymousObjectField                 ::= VarInitDeclaration: field
                                         {: RESULT = field; :}
                                       | LocalConstDeclaration: field
                                         {: RESULT = field; :};

ConstructorCallExpression ::= Type: type Arguments: arguments
                              {: RESULT = new ConstructorCallExpressionNode(type, arguments); :};

// Other
Type     ::= TypeName: name
             {: RESULT = new Type(name); :}
           | TypeName: name LT Type: param GT
             {: RESULT = new Type(name, param); :};
TypeName ::= TYPE: name
             {: RESULT = name; :}
           | GLOBAL: name
             {: RESULT = name; :};

Designator           ::= IDENTIFIER;
//                       | ArrayAccess
//                       | FieldAccess;
//ArrayAccess          ::= DesignableExpression SQUARE_L Expression SQUARE_R;
//FieldAccess          ::= DesignableExpression POINT IDENTIFIER;
// TODO only certain expressions (variable (or constant), array, point, function call, etc)
DesignableExpression ::= IDENTIFIER;

Arguments    ::= PARENTH_L PARENTH_R
                 {: RESULT = new ArrayList<>(); :}
               | PARENTH_L ArgumentList: arguments PARENTH_R
                 {: RESULT = arguments; :};
ArgumentList ::= Expression: argument
                 {: RESULT = new ArrayList<>(Collections.singletonList(argument)); :}
               | ArgumentList: arguments COMMA Expression: argument
                 {: arguments.add(argument); RESULT = arguments; :};