package syntactical;

import java_cup.runtime.*;
import lexical.LexicalAnalyser;
import lexical.LexicalUnit;
import syntactical.ast.*;
import error.SyntacticalException;

import java.util.*;

init with {::}
scan with {:
    return analyser.next_token();
:}
action code {::}
parser code {:
    private LexicalAnalyser analyser = (LexicalAnalyser) getScanner();
:}

// TODO types etc

terminal INT, REAL, CHAR, STRING, IF, ELSE, SWITCH, FOR, WHILE, IN, RETURN,
         TRUE, FALSE, NOTHING, NULL, CONST, CLASS, CONSTRUCTOR,
         THIS, UNDERSCORE, PARENTH_L, PARENTH_R, SQUARE_L, SQUARE_R,
         CURLY_L, CURLY_R, ARROW, ELLIPSIS, POINT, COMMA, PLUS_ASSIGN, PLUS,
         MINUS_ASSIGN, MINUS, MULT_ASSIGN, MULT, DIV_ASSIGN, DIV, MOD_ASSIGN, MOD,
         LE, LT, GE, GT, IDENTITY, EQUALS, NEQ, ASSIGNMENT, NOT, AND, OR, END;
terminal String IDENTIFIER, IMPORT;

// Program
nonterminal ProgramNode Program;
// Imports
nonterminal List<String> ImportList;
nonterminal String Import, FilePath;
// Declarations
nonterminal DeclarationNode DeclarationList, Declaration;
// Variables
nonterminal VarDeclarationNode VarDeclaration, GlobalVarConstDeclaration, VarConstDeclaration, VarInitDeclaration,
            GlobalConstDeclaration, LocalConstDeclaration;
nonterminal Name BaseVarDeclaration;
// Functions
nonterminal FunctionDeclarationNode FunctionDeclaration;
nonterminal List<Name> FunctionParameters, ParameterList;
// Classes
nonterminal ClassDeclarationNode ClassDeclaration;
nonterminal DeclarationNode ClassBlock, ClassElementList, ClassElement;
nonterminal ConstructorDeclarationNode ConstructorDeclaration;
// Statements
nonterminal StatementNode StatementList, Statement;
nonterminal BlockStatementNode BlockStatement, ElseBlockStatement;
nonterminal VarDeclarationStatementNode VarDeclarationStatement;
nonterminal IfElseStatementNode IfElseStatement;
// Expressions
nonterminal ExpressionNode Expression;
// Other (to check case)
nonterminal String TypeName, VarId, GlobalConstId;
nonterminal Type Type;

// TODO Statement, Expression

// Program
Program ::= ImportList: imports DeclarationList: declarations
            {: RESULT = new ProgramNode(declarations, imports); :};

// Imports
ImportList ::= ImportList: imports Import: file
               {: imports.add(file); RESULT = imports; :}
             |
               {: RESULT = new ArrayList<>(); :};
Import     ::= IMPORT FilePath: path END
               {: RESULT = path; :};
FilePath   ::= FilePath: path DIV IDENTIFIER: filename
               {: RESULT = path + "/" + filename; :}
             | IDENTIFIER: filename
               {: RESULT = filename; :};

// Declarations
DeclarationList ::= Declaration: declaration DeclarationList: declarations
                    {: RESULT = declaration.linkedTo(declarations); :}
                  |
                    {: RESULT = null; :};
Declaration     ::= GlobalVarConstDeclaration: declaration
                    {: RESULT = declaration; :}
                  | FunctionDeclaration: declaration
                    {: RESULT = declaration; :}
                  | ClassDeclaration: declaration
                    {: RESULT = declaration; :};

// Variables
GlobalVarConstDeclaration ::= VarDeclaration: declaration
                              {: RESULT = declaration; :}
                            | GlobalConstDeclaration: declaration END
                              {: RESULT = declaration; :};
VarConstDeclaration       ::= VarDeclaration: declaration
                              {: RESULT = declaration; :}
                            | LocalConstDeclaration: declaration END
                              {: RESULT = declaration; :};
VarDeclaration            ::= BaseVarDeclaration: declaration END
                              {: RESULT = new VarDeclarationNode(declaration); :}
                            | VarInitDeclaration: declaration END
                              {: RESULT = declaration; :};
BaseVarDeclaration        ::= Type: type VarId: id
                              {: RESULT = new Name(id, type); :};
VarInitDeclaration        ::= BaseVarDeclaration: name ASSIGNMENT Expression: initialValue
                              {: RESULT = new VarDeclarationNode(name, initialValue); :};
GlobalConstDeclaration    ::= CONST Type: type GlobalConstId: id ASSIGNMENT Expression: initialValue
                              {: RESULT = new VarDeclarationNode(new Name(id, type), initialValue, true, true); :};
LocalConstDeclaration     ::= CONST VarInitDeclaration: declaration
                              {: RESULT = declaration.constant(); :};

// Functions
FunctionDeclaration ::= BaseVarDeclaration: name FunctionParameters: parameters BlockStatement: block
                        {: RESULT = new FunctionDeclarationNode(name, parameters, block); :};
FunctionParameters  ::= PARENTH_L PARENTH_R
                        {: RESULT = new ArrayList<>(); :}
                      | PARENTH_L ParameterList: parameters PARENTH_R
                        {: RESULT = parameters; :};
ParameterList       ::= BaseVarDeclaration: parameter
                        {: RESULT = new ArrayList<Name>() {{ add(parameter); }}; :}
                      | ParameterList: parameters COMMA BaseVarDeclaration: parameter
                        {: parameters.add(parameter); RESULT = parameters; :};

// Classes
ClassDeclaration       ::= CLASS TypeName: name ClassBlock: block
                           {: RESULT = new ClassDeclarationNode(name, block); :};
ClassBlock             ::= CURLY_L ClassElementList: contents CURLY_R
                           {: RESULT = contents; :};
ClassElementList       ::= ClassElement: element ClassElementList: elements
                           {: RESULT = element.linkedTo(elements); :}
                         |
                           {: RESULT = null; :};
ClassElement           ::= VarConstDeclaration: declaration
                           {: RESULT = declaration; :}
                         | ConstructorDeclaration: declaration
                           {: RESULT = declaration; :}
                         | FunctionDeclaration: declaration
                           {: RESULT = declaration; :};
ConstructorDeclaration ::= CONSTRUCTOR FunctionParameters: parameters BlockStatement: block
                           {: RESULT = new ConstructorDeclarationNode(parameters, block); :};

// Statements
StatementList           ::= Statement: statement StatementList: statements
                            {: RESULT = statement.linkedTo(statements); :}
                          |
                            {: RESULT = null; :};
Statement               ::= VarDeclarationStatement: statement
                            {: RESULT = statement; :}
                          | IfElseStatement: statement
                            {: RESULT = statement; :};
BlockStatement          ::= CURLY_L StatementList: root CURLY_R
                            {: RESULT = new BlockStatementNode(root); :};
VarDeclarationStatement ::= VarConstDeclaration: declaration
                            {: RESULT = declaration.asStatement(); :};
IfElseStatement         ::= IF Expression: condition BlockStatement: ifBlock ElseBlockStatement: elseBlock
                            {: RESULT = new IfElseStatementNode(condition, ifBlock, elseBlock); :};
ElseBlockStatement      ::= ELSE BlockStatement: elseBlock
                            {: RESULT = elseBlock; :}
                          | ELSE IfElseStatement: ifElse
                            {: RESULT = new BlockStatementNode(ifElse); :}
                          |
                            {: RESULT = null; :};
// TODO: fix it to return actual blocks
SwitchStatement         ::= SWITCH VarId: variable CURLY_L SwitchCasesStatement : cases CURLY_R
SwitchCasesStatement    ::= Expression: case ARROW BlockStatement: block
                            {: RESULT = new ArrayList<>() {{ add(case); }}; :}
                          | SwitchCasesStatement : cases Expression: case ARROW BlockStatement: block
                            {: cases.add(case); RESULT = cases; :}
// Other
Type          ::= TypeName: name
                  {: RESULT = new Type(name); :}
                | TypeName: name LT Type: param GT
                  {: RESULT = new Type(name, param); :};
TypeName      ::= IDENTIFIER: id {: RESULT = id; :};
VarId         ::= IDENTIFIER: id {: RESULT = id; :};
GlobalConstId ::= IDENTIFIER: id {: RESULT = id; :};