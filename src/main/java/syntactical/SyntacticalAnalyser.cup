package syntactical;

import java_cup.runtime.*;
import lexical.LexicalAnalyser;
import lexical.LexicalUnit;
import syntactical.ast.*;
import error.SyntacticalException;

import java.util.*;

init with {::}
scan with {:
    return analyser.next_token();
:}
action code {::}
parser code {:
    private LexicalAnalyser analyser = (LexicalAnalyser) getScanner();
:}

// TODO types etc

terminal IF, ELSE, SWITCH, FOR, WHILE, IN, RETURN, CONST, CLASS, CONSTRUCTOR, THIS, UNDERSCORE, PARENTH_L,
         PARENTH_R, SQUARE_L, SQUARE_R, CURLY_L, CURLY_R, ARROW, ELLIPSIS, POINT, COMMA, PLUS_ASSIGN, PLUS,
         MINUS_ASSIGN, MINUS, MULT_ASSIGN, MULT, DIV_ASSIGN, DIV, MOD_ASSIGN, MOD, LE, LT, GE, GT, IDENTITY, EQUALS,
         NEQ, ASSIGNMENT, NOT, AND, OR, END;
terminal String IDENTIFIER, GLOBAL, TYPE, IMPORT;
terminal String INT, REAL, CHAR, STRING, TRUE, FALSE, NOTHING, NULL;

// Program
nonterminal ProgramNode Program;
// Imports
nonterminal List<String> ImportList;
nonterminal String Import, FilePath, Filename;
// Declarations
nonterminal DeclarationNode DeclarationList, Declaration;
// Variables
nonterminal VarDeclarationNode VarDeclaration, GlobalVarConstDeclaration, VarConstDeclaration, VarInitDeclaration,
            GlobalConstDeclaration, LocalConstDeclaration;
nonterminal Name BaseVarDeclaration;
// Functions
nonterminal FunctionDeclarationNode FunctionDeclaration;
nonterminal List<Name> FunctionParameters, ParameterList;
// Classes
nonterminal ClassDeclarationNode ClassDeclaration;
nonterminal DeclarationNode ClassBlock, ClassElementList, ClassElement;
nonterminal ConstructorDeclarationNode ConstructorDeclaration;
// Statements
nonterminal StatementNode StatementList, Statement;
// Block
nonterminal BlockStatementNode BlockStatement;
// Declaration statements
nonterminal VarDeclarationStatementNode VarDeclarationStatement;
// Assignment
nonterminal AssignmentStatementNode AssignmentStatement;
// Function call
nonterminal FunctionCallStatementNode FunctionCallStatement;
nonterminal List<ExpressionNode> FunctionArguments, ArgumentList;
// Return
nonterminal ReturnStatementNode ReturnStatement;
// Conditionals
nonterminal IfElseStatementNode IfElseStatement;
nonterminal StatementNode ElsePartStatement;
nonterminal SwitchStatementNode SwitchStatement;
nonterminal Map<ExpressionNode,StatementNode> SwitchCasesStatement;
// Loops
nonterminal WhileStatementNode WhileStatement;
nonterminal ForStatementNode ForStatement;
// Expressions
nonterminal ExpressionNode Expression;
// Constants
nonterminal ConstantExpressionNode ConstantExpression;
nonterminal ListConstructorExpressionNode ListConstructorExpression;
nonterminal List<ExpressionNode> ListElements;
nonterminal AnonymousObjectConstructorExpressionNode AnonymousObjectConstructorExpression;
nonterminal VarDeclarationNode AnonymousObjectFields, AnonymousObjectField;
// Other
nonterminal String TypeName;
nonterminal Type Type;
nonterminal Designator Designator;
nonterminal ExpressionNode ArrayAccess, FieldAccess, DesignableExpression;

// TODO Statement (function call from expression and operational assignments +=, *=... (and maybe more things)), Expression

// Program
Program ::= ImportList: imports DeclarationList: declarations
            {: RESULT = new ProgramNode(declarations, imports); :};

// Imports
ImportList ::= ImportList: imports Import: file
               {: imports.add(file); RESULT = imports; :}
             |
               {: RESULT = new ArrayList<>(); :};
Import     ::= IMPORT FilePath: path END
               {: RESULT = path; :};
FilePath   ::= FilePath: path DIV Filename: filename
               {: RESULT = path + "/" + filename; :}
             | Filename: filename
               {: RESULT = filename; :};
Filename   ::= IDENTIFIER: name
               {: RESULT = name; :}
               | GLOBAL: name
               {: RESULT = name; :}
               | TYPE: name
               {: RESULT = name; :};

// Declarations
DeclarationList ::= Declaration: declaration DeclarationList: declarations
                    {: RESULT = declaration.linkedTo(declarations); :}
                  |
                    {: RESULT = null; :};
Declaration     ::= GlobalVarConstDeclaration: declaration
                    {: RESULT = declaration; :}
                  | FunctionDeclaration: declaration
                    {: RESULT = declaration; :}
                  | ClassDeclaration: declaration
                    {: RESULT = declaration; :};

// Variables
GlobalVarConstDeclaration ::= VarDeclaration: declaration
                              {: RESULT = declaration; :}
                            | GlobalConstDeclaration: declaration END
                              {: RESULT = declaration; :};
VarConstDeclaration       ::= VarDeclaration: declaration
                              {: RESULT = declaration; :}
                            | LocalConstDeclaration: declaration END
                              {: RESULT = declaration; :};
VarDeclaration            ::= BaseVarDeclaration: declaration END
                              {: RESULT = new VarDeclarationNode(declaration); :}
                            | VarInitDeclaration: declaration END
                              {: RESULT = declaration; :};
BaseVarDeclaration        ::= Type: type IDENTIFIER: id
                              {: RESULT = new Name(id, type); :};
VarInitDeclaration        ::= BaseVarDeclaration: name ASSIGNMENT Expression: initialValue
                              {: RESULT = new VarDeclarationNode(name, initialValue); :};
GlobalConstDeclaration    ::= CONST Type: type GLOBAL: id ASSIGNMENT Expression: initialValue
                              {: RESULT = new VarDeclarationNode(new Name(id, type), initialValue, true, true); :};
LocalConstDeclaration     ::= CONST VarInitDeclaration: declaration
                              {: RESULT = declaration.constant(); :};

// Functions
FunctionDeclaration ::= BaseVarDeclaration: name FunctionParameters: parameters BlockStatement: block
                        {: RESULT = new FunctionDeclarationNode(name, parameters, block); :};
FunctionParameters  ::= PARENTH_L PARENTH_R
                        {: RESULT = new ArrayList<>(); :}
                      | PARENTH_L ParameterList: parameters PARENTH_R
                        {: RESULT = parameters; :};
ParameterList       ::= BaseVarDeclaration: parameter
                        {: RESULT = new ArrayList<>(Collections.singletonList(parameter)); :}
                      | ParameterList: parameters COMMA BaseVarDeclaration: parameter
                        {: parameters.add(parameter); RESULT = parameters; :};

// Classes
ClassDeclaration       ::= CLASS TypeName: name ClassBlock: block
                           {: RESULT = new ClassDeclarationNode(name, block); :};
ClassBlock             ::= CURLY_L ClassElementList: contents CURLY_R
                           {: RESULT = contents; :};
ClassElementList       ::= ClassElement: element ClassElementList: elements
                           {: RESULT = element.linkedTo(elements); :}
                         |
                           {: RESULT = null; :};
ClassElement           ::= VarConstDeclaration: declaration
                           {: RESULT = declaration; :}
                         | ConstructorDeclaration: declaration
                           {: RESULT = declaration; :}
                         | FunctionDeclaration: declaration
                           {: RESULT = declaration; :};
ConstructorDeclaration ::= CONSTRUCTOR FunctionParameters: parameters BlockStatement: block
                           {: RESULT = new ConstructorDeclarationNode(parameters, block); :};

// Statements
StatementList ::= Statement: statement StatementList: statements
                  {: RESULT = statement.linkedTo(statements); :}
                |
                  {: RESULT = null; :};
Statement     ::= VarDeclarationStatement: statement
                  {: RESULT = statement; :}
                | AssignmentStatement: statement
                  {: RESULT = statement; :}
                | FunctionCallStatement: statement
                  {: RESULT = statement; :}
                | ReturnStatement: statement
                  {: RESULT = statement; :}
                | IfElseStatement: statement
                  {: RESULT = statement; :}
                | SwitchStatement: statement
                  {: RESULT = statement; :}
                | WhileStatement: statement
                  {: RESULT = statement; :}
                | ForStatement: statement
                  {: RESULT = statement; :}
                | BlockStatement: statement
                  {: RESULT = statement; :};

// Block
BlockStatement ::= CURLY_L StatementList: root CURLY_R
                   {: RESULT = new BlockStatementNode(root); :};

// Declaration statements
VarDeclarationStatement ::= VarConstDeclaration: declaration
                            {: RESULT = declaration.asStatement(); :};

// Assignment
AssignmentStatement ::= Designator: designator ASSIGNMENT Expression: expression END
                        {: RESULT = new AssignmentStatementNode(designator, expression); :};

// Function call TODO fix conflicts with anonymous objects
//FunctionCallStatement ::= Expression: function FunctionArguments: arguments END
//                          {: RESULT = new FunctionCallStatementNode(function, arguments); :};
//FunctionArguments     ::= PARENTH_L PARENTH_R
//                          {: RESULT = new ArrayList<>(); :}
//                        | PARENTH_L ArgumentList: arguments PARENTH_R
//                          {: RESULT = arguments; :};
//ArgumentList          ::= Expression: argument
//                          {: RESULT = new ArrayList<>(Collections.singletonList(argument)); :}
//                        | ArgumentList: arguments COMMA Expression: argument
//                          {: arguments.add(argument); RESULT = arguments; :};

// Return
ReturnStatement ::= RETURN END
                    {: RESULT = new ReturnStatementNode(); :}
                  | RETURN Expression: expression END
                    {: RESULT = new ReturnStatementNode(expression); :};

// Conditionals
IfElseStatement   ::= IF Expression: condition BlockStatement: ifBlock ElsePartStatement: elsePart
                      {: RESULT = new IfElseStatementNode(condition, ifBlock, elsePart); :};
ElsePartStatement ::= ELSE BlockStatement: elseBlock
                      {: RESULT = elseBlock; :}
                    | ELSE IfElseStatement: ifElse
                      {: RESULT = ifElse; :}
                    |
                      {: RESULT = null; :};

SwitchStatement      ::= SWITCH Expression: expression CURLY_L SwitchCasesStatement: cases CURLY_R
                         {: RESULT = new SwitchStatementNode(expression, cases); :};
SwitchCasesStatement ::= ConstantExpression: expression ARROW Statement: statement
                         {: RESULT = new HashMap<>(Collections.singletonMap(expression, statement)); :}
                       | SwitchCasesStatement: cases Expression: expression ARROW Statement: statement
                         {: cases.put(expression, statement); RESULT = cases; :};

// Loops
WhileStatement ::= WHILE Expression: condition BlockStatement: whileBlock
                    {: RESULT = new WhileStatementNode(condition, whileBlock); :};

ForStatement ::= FOR BaseVarDeclaration: variable IN Expression: iterable BlockStatement: forBlock
                    {: RESULT = new ForStatementNode(variable, iterable, forBlock); :};


// Expressions TODO
Expression ::= ConstantExpression: expression
               {: RESULT = expression; :}
             | ListConstructorExpression: expression
               {: RESULT = expression; :}
             | AnonymousObjectConstructorExpression: expression
               {: RESULT = expression; :};

// Constants
ConstantExpression ::= INT: n
                       {: RESULT = ConstantExpressionNode.fromInt(n); :}
                     | REAL: x
                       {: RESULT = ConstantExpressionNode.fromFloat(x); :}
                     | TRUE: t
                       {: RESULT = ConstantExpressionNode.fromBoolean(t); :}
                     | FALSE: f
                       {: RESULT = ConstantExpressionNode.fromBoolean(f); :}
                     | CHAR: c
                       {: RESULT = ConstantExpressionNode.fromChar(c); :}
                     | NOTHING
                       {: RESULT = ConstantExpressionNode.ofNothing(); :}
                     | NULL
                       {: RESULT = ConstantExpressionNode.ofNull(); :}
                     | UNDERSCORE
                       {: RESULT = ConstantExpressionNode.ofNull(); :};

ListConstructorExpression ::= STRING: str
                              {: RESULT = ListConstructorExpressionNode.fromString(str); :}
                            | SQUARE_L SQUARE_R
                              {: RESULT = new ListConstructorExpressionNode(); :}
                            | SQUARE_L ListElements: elements SQUARE_R
                              {: RESULT = new ListConstructorExpressionNode(elements); :};
ListElements              ::= Expression: element
                              {: RESULT = new ArrayList<>(Collections.singletonList(element)); :}
                            | ListElements: elements COMMA Expression: element
                              {: elements.add(element); RESULT = elements; :};

AnonymousObjectConstructorExpression ::= CURLY_L CURLY_R
                                         {: RESULT = new AnonymousObjectConstructorExpressionNode(); :}
                                       | CURLY_L AnonymousObjectFields: fields CURLY_R
                                         {: RESULT = new AnonymousObjectConstructorExpressionNode(fields); :};
AnonymousObjectFields                ::= AnonymousObjectField: field
                                         {: RESULT = field; :}
                                       | AnonymousObjectField: field COMMA AnonymousObjectFields: fields
                                         {: field.linkedTo(fields); RESULT = field; :};
AnonymousObjectField                 ::= VarInitDeclaration: field
                                         {: RESULT = field; :}
                                       | LocalConstDeclaration: field
                                         {: RESULT = field; :};

// Other
Type     ::= TypeName: name
             {: RESULT = new Type(name); :}
           | TypeName: name LT Type: param GT
             {: RESULT = new Type(name, param); :};
TypeName ::= TYPE: name
             {: RESULT = name; :}
           | GLOBAL: name
             {: RESULT = name; :};

Designator           ::= IDENTIFIER
                       | ArrayAccess
                       | FieldAccess;
ArrayAccess          ::= DesignableExpression SQUARE_L Expression SQUARE_R;
FieldAccess          ::= DesignableExpression POINT IDENTIFIER;
// TODO only certain expressions (variable (or constant), array, point, function call, etc)
DesignableExpression ::= IDENTIFIER;
