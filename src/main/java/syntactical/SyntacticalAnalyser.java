
//----------------------------------------------------
// The following code was generated by CUP v0.11b beta 20140220
// Sat Apr 25 14:56:57 CEST 2020
//----------------------------------------------------

package syntactical;

import java_cup.runtime.*;
import lexical.LexicalAnalyser;
import lexical.LexicalUnit;
import syntactical.ast.*;
import error.SyntacticalException;
import java.util.*;
import java_cup.runtime.ComplexSymbolFactory.Location;

/** CUP v0.11b beta 20140220 generated parser.
  * @version Sat Apr 25 14:56:57 CEST 2020
  */
public class SyntacticalAnalyser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public SyntacticalAnalyser() {super();}

  /** Constructor which sets the default scanner. */
  public SyntacticalAnalyser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public SyntacticalAnalyser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\126\000\002\002\004\000\002\002\004\000\002\003" +
    "\004\000\002\003\002\000\002\004\005\000\002\005\005" +
    "\000\002\005\003\000\002\006\004\000\002\006\002\000" +
    "\002\007\003\000\002\007\003\000\002\007\003\000\002" +
    "\011\003\000\002\011\004\000\002\012\003\000\002\012" +
    "\004\000\002\010\004\000\002\010\004\000\002\016\004" +
    "\000\002\013\005\000\002\014\007\000\002\015\004\000" +
    "\002\017\005\000\002\020\004\000\002\020\005\000\002" +
    "\021\003\000\002\021\005\000\002\022\005\000\002\023" +
    "\005\000\002\024\004\000\002\024\002\000\002\025\003" +
    "\000\002\025\003\000\002\025\003\000\002\026\005\000" +
    "\002\027\004\000\002\027\002\000\002\030\003\000\002" +
    "\030\003\000\002\030\003\000\002\030\003\000\002\030" +
    "\003\000\002\030\003\000\002\030\003\000\002\030\003" +
    "\000\002\031\005\000\002\032\003\000\002\033\006\000" +
    "\002\034\005\000\002\035\004\000\002\035\005\000\002" +
    "\036\003\000\002\036\005\000\002\037\004\000\002\037" +
    "\005\000\002\040\006\000\002\041\004\000\002\041\004" +
    "\000\002\041\002\000\002\042\007\000\002\043\005\000" +
    "\002\043\006\000\002\044\005\000\002\045\003\000\002" +
    "\045\003\000\002\045\003\000\002\046\003\000\002\046" +
    "\003\000\002\046\003\000\002\046\003\000\002\046\003" +
    "\000\002\046\003\000\002\046\003\000\002\046\003\000" +
    "\002\047\003\000\002\054\003\000\002\054\006\000\002" +
    "\050\003\000\002\051\003\000\002\052\003\000\002\055" +
    "\003\000\002\055\003\000\002\055\003\000\002\056\006" +
    "\000\002\057\005\000\002\060\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\221\000\014\002\ufffe\014\ufffe\015\ufffe\061\ufffe\062" +
    "\ufffe\001\002\000\004\002\223\001\002\000\014\002\ufff9" +
    "\014\025\015\024\061\021\062\023\001\002\000\004\061" +
    "\152\001\002\000\014\002\uffff\014\uffff\015\uffff\061\uffff" +
    "\062\uffff\001\002\000\004\060\221\001\002\000\012\002" +
    "\ufff9\014\025\015\024\061\021\001\002\000\012\002\ufff6" +
    "\014\ufff6\015\ufff6\061\ufff6\001\002\000\012\002\ufff5\014" +
    "\ufff5\015\ufff5\061\ufff5\001\002\000\004\002\001\001\002" +
    "\000\010\021\070\054\065\060\144\001\002\000\012\002" +
    "\ufff8\014\ufff8\015\ufff8\061\ufff8\001\002\000\010\046\213" +
    "\050\uffb6\061\uffb6\001\002\000\012\002\ufff7\014\ufff7\015" +
    "\ufff7\061\ufff7\001\002\000\012\025\uffb4\046\uffb4\050\uffb4" +
    "\061\uffb4\001\002\000\004\060\212\001\002\000\004\061" +
    "\206\001\002\000\004\061\021\001\002\000\004\061\021" +
    "\001\002\000\004\061\027\001\002\000\004\054\uffb2\001" +
    "\002\000\004\054\031\001\002\000\026\004\040\020\046" +
    "\061\044\063\032\064\043\065\045\066\036\067\042\070" +
    "\033\071\037\001\002\000\020\021\uffbf\022\uffbf\024\uffbf" +
    "\025\uffbf\027\uffbf\032\uffbf\060\uffbf\001\002\000\020\021" +
    "\uffba\022\uffba\024\uffba\025\uffba\027\uffba\032\uffba\060\uffba" +
    "\001\002\000\020\021\uffc0\022\uffc0\024\uffc0\025\uffc0\027" +
    "\uffc0\032\uffc0\060\uffc0\001\002\000\020\021\uffc1\022\uffc1" +
    "\024\uffc1\025\uffc1\027\uffc1\032\uffc1\060\uffc1\001\002\000" +
    "\020\021\uffbd\022\uffbd\024\uffbd\025\uffbd\027\uffbd\032\uffbd" +
    "\060\uffbd\001\002\000\020\021\uffb9\022\uffb9\024\uffb9\025" +
    "\uffb9\027\uffb9\032\uffb9\060\uffb9\001\002\000\020\021\uffb7" +
    "\022\uffb7\024\uffb7\025\uffb7\027\uffb7\032\uffb7\060\uffb7\001" +
    "\002\000\004\060\uffed\001\002\000\020\021\uffbc\022\uffbc" +
    "\024\uffbc\025\uffbc\027\uffbc\032\uffbc\060\uffbc\001\002\000" +
    "\020\021\uffbe\022\uffbe\024\uffbe\025\uffbe\027\uffbe\032\uffbe" +
    "\060\uffbe\001\002\000\016\022\uffc2\024\uffc2\025\uffc2\027" +
    "\uffc2\032\uffc2\060\uffc2\001\002\000\020\021\uffbb\022\uffbb" +
    "\024\uffbb\025\uffbb\027\uffbb\032\uffbb\060\uffbb\001\002\000" +
    "\020\021\uffb8\022\uffb8\024\uffb8\025\uffb8\027\uffb8\032\uffb8" +
    "\060\uffb8\001\002\000\004\025\050\001\002\000\012\014" +
    "\062\016\061\026\uffe3\061\021\001\002\000\012\002\uffe6" +
    "\014\uffe6\015\uffe6\061\uffe6\001\002\000\012\014\062\016" +
    "\061\026\uffe3\061\021\001\002\000\012\014\uffe1\016\uffe1" +
    "\026\uffe1\061\uffe1\001\002\000\046\004\ufff3\005\ufff3\007" +
    "\ufff3\011\ufff3\013\ufff3\014\ufff3\016\ufff3\020\ufff3\025\ufff3" +
    "\026\ufff3\061\ufff3\063\ufff3\064\ufff3\065\ufff3\066\ufff3\067" +
    "\ufff3\070\ufff3\071\ufff3\001\002\000\012\014\uffe2\016\uffe2" +
    "\026\uffe2\061\uffe2\001\002\000\004\060\203\001\002\000" +
    "\004\026\202\001\002\000\012\014\uffe0\016\uffe0\026\uffe0" +
    "\061\uffe0\001\002\000\004\021\070\001\002\000\004\061" +
    "\021\001\002\000\004\054\065\001\002\000\004\060\uffec" +
    "\001\002\000\026\004\040\020\046\061\044\063\032\064" +
    "\043\065\045\066\036\067\042\070\033\071\037\001\002" +
    "\000\004\060\uffee\001\002\000\004\025\100\001\002\000" +
    "\006\022\073\061\021\001\002\000\006\022\075\032\074" +
    "\001\002\000\006\022\uffe8\032\uffe8\001\002\000\004\025" +
    "\uffea\001\002\000\004\061\021\001\002\000\004\025\uffe9" +
    "\001\002\000\006\022\uffe7\032\uffe7\001\002\000\012\014" +
    "\uffdf\016\uffdf\026\uffdf\061\uffdf\001\002\000\044\004\040" +
    "\005\106\007\115\011\122\013\111\014\062\020\046\025" +
    "\100\026\uffdd\061\127\063\032\064\043\065\045\066\036" +
    "\067\042\070\033\071\037\001\002\000\004\054\uffb0\001" +
    "\002\000\010\023\uffac\031\uffac\054\uffb1\001\002\000\004" +
    "\026\201\001\002\000\044\004\uffd7\005\uffd7\007\uffd7\011" +
    "\uffd7\013\uffd7\014\uffd7\020\uffd7\025\uffd7\026\uffd7\061\uffd7" +
    "\063\uffd7\064\uffd7\065\uffd7\066\uffd7\067\uffd7\070\uffd7\071" +
    "\uffd7\001\002\000\004\054\176\001\002\000\026\004\040" +
    "\020\046\061\044\063\032\064\043\065\045\066\036\067" +
    "\042\070\033\071\037\001\002\000\044\004\uffdb\005\uffdb" +
    "\007\uffdb\011\uffdb\013\uffdb\014\uffdb\020\uffdb\025\uffdb\026" +
    "\uffdb\061\uffdb\063\uffdb\064\uffdb\065\uffdb\066\uffdb\067\uffdb" +
    "\070\uffdb\071\uffdb\001\002\000\044\004\uffda\005\uffda\007" +
    "\uffda\011\uffda\013\uffda\014\uffda\020\uffda\025\uffda\026\uffda" +
    "\061\uffda\063\uffda\064\uffda\065\uffda\066\uffda\067\uffda\070" +
    "\uffda\071\uffda\001\002\000\030\004\040\020\046\060\166" +
    "\061\044\063\032\064\043\065\045\066\036\067\042\070" +
    "\033\071\037\001\002\000\044\004\uffd3\005\uffd3\007\uffd3" +
    "\011\uffd3\013\uffd3\014\uffd3\020\uffd3\025\uffd3\026\uffd3\061" +
    "\uffd3\063\uffd3\064\uffd3\065\uffd3\066\uffd3\067\uffd3\070\uffd3" +
    "\071\uffd3\001\002\000\044\004\uffd8\005\uffd8\007\uffd8\011" +
    "\uffd8\013\uffd8\014\uffd8\020\uffd8\025\uffd8\026\uffd8\061\uffd8" +
    "\063\uffd8\064\uffd8\065\uffd8\066\uffd8\067\uffd8\070\uffd8\071" +
    "\uffd8\001\002\000\044\004\uffd9\005\uffd9\007\uffd9\011\uffd9" +
    "\013\uffd9\014\uffd9\020\uffd9\025\uffd9\026\uffd9\061\uffd9\063" +
    "\uffd9\064\uffd9\065\uffd9\066\uffd9\067\uffd9\070\uffd9\071\uffd9" +
    "\001\002\000\026\004\040\020\046\061\044\063\032\064" +
    "\043\065\045\066\036\067\042\070\033\071\037\001\002" +
    "\000\044\004\uffdc\005\uffdc\007\uffdc\011\uffdc\013\uffdc\014" +
    "\uffdc\020\uffdc\025\uffdc\026\uffdc\061\uffdc\063\uffdc\064\uffdc" +
    "\065\uffdc\066\uffdc\067\uffdc\070\uffdc\071\uffdc\001\002\000" +
    "\006\023\146\031\145\001\002\000\006\054\065\060\144" +
    "\001\002\000\004\054\uffaf\001\002\000\026\004\040\020" +
    "\046\061\044\063\032\064\043\065\045\066\036\067\042" +
    "\070\033\071\037\001\002\000\044\004\040\005\106\007" +
    "\115\011\122\013\111\014\062\020\046\025\100\026\uffdd" +
    "\061\127\063\032\064\043\065\045\066\036\067\042\070" +
    "\033\071\037\001\002\000\004\021\130\001\002\000\044" +
    "\004\uffd6\005\uffd6\007\uffd6\011\uffd6\013\uffd6\014\uffd6\020" +
    "\uffd6\025\uffd6\026\uffd6\061\uffd6\063\uffd6\064\uffd6\065\uffd6" +
    "\066\uffd6\067\uffd6\070\uffd6\071\uffd6\001\002\000\044\004" +
    "\uffd5\005\uffd5\007\uffd5\011\uffd5\013\uffd5\014\uffd5\020\uffd5" +
    "\025\uffd5\026\uffd5\061\uffd5\063\uffd5\064\uffd5\065\uffd5\066" +
    "\uffd5\067\uffd5\070\uffd5\071\uffd5\001\002\000\016\021\uffc2" +
    "\023\uffb3\031\uffb3\046\uffb4\054\uffb3\061\uffb4\001\002\000" +
    "\030\004\040\020\046\022\135\061\044\063\032\064\043" +
    "\065\045\066\036\067\042\070\033\071\037\001\002\000" +
    "\004\060\132\001\002\000\044\004\uffd1\005\uffd1\007\uffd1" +
    "\011\uffd1\013\uffd1\014\uffd1\020\uffd1\025\uffd1\026\uffd1\061" +
    "\uffd1\063\uffd1\064\uffd1\065\uffd1\066\uffd1\067\uffd1\070\uffd1" +
    "\071\uffd1\001\002\000\006\022\uffce\032\uffce\001\002\000" +
    "\006\022\137\032\136\001\002\000\004\060\uffd0\001\002" +
    "\000\026\004\040\020\046\061\044\063\032\064\043\065" +
    "\045\066\036\067\042\070\033\071\037\001\002\000\004" +
    "\060\uffcf\001\002\000\006\022\uffcd\032\uffcd\001\002\000" +
    "\004\026\uffde\001\002\000\004\025\100\001\002\000\044" +
    "\004\uffc3\005\uffc3\007\uffc3\011\uffc3\013\uffc3\014\uffc3\020" +
    "\uffc3\025\uffc3\026\uffc3\061\uffc3\063\uffc3\064\uffc3\065\uffc3" +
    "\066\uffc3\067\uffc3\070\uffc3\071\uffc3\001\002\000\052\002" +
    "\ufff1\004\ufff1\005\ufff1\007\ufff1\011\ufff1\013\ufff1\014\ufff1" +
    "\015\ufff1\016\ufff1\020\ufff1\025\ufff1\026\ufff1\061\ufff1\063" +
    "\ufff1\064\ufff1\065\ufff1\066\ufff1\067\ufff1\070\ufff1\071\ufff1" +
    "\001\002\000\004\061\152\001\002\000\026\004\040\020" +
    "\046\061\044\063\032\064\043\065\045\066\036\067\042" +
    "\070\033\071\037\001\002\000\004\024\150\001\002\000" +
    "\004\054\uffae\001\002\000\004\054\uffad\001\002\000\014" +
    "\021\uffb3\022\uffb3\032\uffb3\054\uffb3\060\uffb3\001\002\000" +
    "\004\025\154\001\002\000\026\004\040\020\046\061\044" +
    "\063\032\064\043\065\045\066\036\067\042\070\033\071" +
    "\037\001\002\000\030\004\040\020\046\026\161\061\044" +
    "\063\032\064\043\065\045\066\036\067\042\070\033\071" +
    "\037\001\002\000\004\027\157\001\002\000\042\004\040" +
    "\005\106\007\115\011\122\013\111\014\062\020\046\025" +
    "\100\061\127\063\032\064\043\065\045\066\036\067\042" +
    "\070\033\071\037\001\002\000\030\004\uffc5\020\uffc5\026" +
    "\uffc5\061\uffc5\063\uffc5\064\uffc5\065\uffc5\066\uffc5\067\uffc5" +
    "\070\uffc5\071\uffc5\001\002\000\044\004\uffc6\005\uffc6\007" +
    "\uffc6\011\uffc6\013\uffc6\014\uffc6\020\uffc6\025\uffc6\026\uffc6" +
    "\061\uffc6\063\uffc6\064\uffc6\065\uffc6\066\uffc6\067\uffc6\070" +
    "\uffc6\071\uffc6\001\002\000\004\027\163\001\002\000\042" +
    "\004\040\005\106\007\115\011\122\013\111\014\062\020" +
    "\046\025\100\061\127\063\032\064\043\065\045\066\036" +
    "\067\042\070\033\071\037\001\002\000\030\004\uffc4\020" +
    "\uffc4\026\uffc4\061\uffc4\063\uffc4\064\uffc4\065\uffc4\066\uffc4" +
    "\067\uffc4\070\uffc4\071\uffc4\001\002\000\004\060\167\001" +
    "\002\000\044\004\uffcc\005\uffcc\007\uffcc\011\uffcc\013\uffcc" +
    "\014\uffcc\020\uffcc\025\uffcc\026\uffcc\061\uffcc\063\uffcc\064" +
    "\uffcc\065\uffcc\066\uffcc\067\uffcc\070\uffcc\071\uffcc\001\002" +
    "\000\044\004\uffcb\005\uffcb\007\uffcb\011\uffcb\013\uffcb\014" +
    "\uffcb\020\uffcb\025\uffcb\026\uffcb\061\uffcb\063\uffcb\064\uffcb" +
    "\065\uffcb\066\uffcb\067\uffcb\070\uffcb\071\uffcb\001\002\000" +
    "\004\025\100\001\002\000\046\004\uffc7\005\uffc7\006\172" +
    "\007\uffc7\011\uffc7\013\uffc7\014\uffc7\020\uffc7\025\uffc7\026" +
    "\uffc7\061\uffc7\063\uffc7\064\uffc7\065\uffc7\066\uffc7\067\uffc7" +
    "\070\uffc7\071\uffc7\001\002\000\006\005\106\025\100\001" +
    "\002\000\044\004\uffca\005\uffca\007\uffca\011\uffca\013\uffca" +
    "\014\uffca\020\uffca\025\uffca\026\uffca\061\uffca\063\uffca\064" +
    "\uffca\065\uffca\066\uffca\067\uffca\070\uffca\071\uffca\001\002" +
    "\000\044\004\uffc9\005\uffc9\007\uffc9\011\uffc9\013\uffc9\014" +
    "\uffc9\020\uffc9\025\uffc9\026\uffc9\061\uffc9\063\uffc9\064\uffc9" +
    "\065\uffc9\066\uffc9\067\uffc9\070\uffc9\071\uffc9\001\002\000" +
    "\044\004\uffc8\005\uffc8\007\uffc8\011\uffc8\013\uffc8\014\uffc8" +
    "\020\uffc8\025\uffc8\026\uffc8\061\uffc8\063\uffc8\064\uffc8\065" +
    "\uffc8\066\uffc8\067\uffc8\070\uffc8\071\uffc8\001\002\000\026" +
    "\004\040\020\046\061\044\063\032\064\043\065\045\066" +
    "\036\067\042\070\033\071\037\001\002\000\004\060\200" +
    "\001\002\000\044\004\uffd2\005\uffd2\007\uffd2\011\uffd2\013" +
    "\uffd2\014\uffd2\020\uffd2\025\uffd2\026\uffd2\061\uffd2\063\uffd2" +
    "\064\uffd2\065\uffd2\066\uffd2\067\uffd2\070\uffd2\071\uffd2\001" +
    "\002\000\054\002\uffd4\004\uffd4\005\uffd4\006\uffd4\007\uffd4" +
    "\011\uffd4\013\uffd4\014\uffd4\015\uffd4\016\uffd4\020\uffd4\025" +
    "\uffd4\026\uffd4\061\uffd4\063\uffd4\064\uffd4\065\uffd4\066\uffd4" +
    "\067\uffd4\070\uffd4\071\uffd4\001\002\000\012\002\uffe5\014" +
    "\uffe5\015\uffe5\061\uffe5\001\002\000\046\004\ufff2\005\ufff2" +
    "\007\ufff2\011\ufff2\013\ufff2\014\ufff2\016\ufff2\020\ufff2\025" +
    "\ufff2\026\ufff2\061\ufff2\063\ufff2\064\ufff2\065\ufff2\066\ufff2" +
    "\067\ufff2\070\ufff2\071\ufff2\001\002\000\004\026\uffe4\001" +
    "\002\000\006\042\207\060\210\001\002\000\006\042\ufffb" +
    "\060\ufffb\001\002\000\004\061\211\001\002\000\014\002" +
    "\ufffd\014\ufffd\015\ufffd\061\ufffd\062\ufffd\001\002\000\006" +
    "\042\ufffc\060\ufffc\001\002\000\052\002\ufff0\004\ufff0\005" +
    "\ufff0\007\ufff0\011\ufff0\013\ufff0\014\ufff0\015\ufff0\016\ufff0" +
    "\020\ufff0\025\ufff0\026\ufff0\061\ufff0\063\ufff0\064\ufff0\065" +
    "\ufff0\066\ufff0\067\ufff0\070\ufff0\071\ufff0\001\002\000\004" +
    "\061\021\001\002\000\004\050\215\001\002\000\006\050" +
    "\uffb5\061\uffb5\001\002\000\004\025\100\001\002\000\016" +
    "\002\uffeb\014\uffeb\015\uffeb\016\uffeb\026\uffeb\061\uffeb\001" +
    "\002\000\004\002\ufffa\001\002\000\012\002\ufff4\014\ufff4" +
    "\015\ufff4\061\ufff4\001\002\000\014\021\uffef\022\uffef\032" +
    "\uffef\054\uffef\060\uffef\001\002\000\004\002\000\001\002" +
    "" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\221\000\006\002\003\003\004\001\001\000\002\001" +
    "\001\000\032\004\006\006\013\007\010\010\012\011\015" +
    "\013\021\014\007\016\014\017\017\022\011\050\016\054" +
    "\005\001\001\000\004\051\221\001\001\000\002\001\001" +
    "\000\002\001\001\000\030\006\217\007\010\010\012\011" +
    "\015\013\021\014\007\016\014\017\017\022\011\050\016" +
    "\054\005\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\020\215\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\005\204\001\001\000\004\050\046" +
    "\001\001\000\006\050\016\054\025\001\001\000\004\052" +
    "\027\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\045\040\046\034\047\033\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\023\050\001" +
    "\001\000\030\010\053\012\054\013\021\015\055\016\014" +
    "\017\057\024\056\025\051\026\052\050\016\054\005\001" +
    "\001\000\002\001\001\000\030\010\053\012\054\013\021" +
    "\015\055\016\014\017\057\024\203\025\051\026\052\050" +
    "\016\054\005\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\020\066\001\001\000\012\013\063" +
    "\016\062\050\016\054\005\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\045\065\046\034\047\033\001\001" +
    "\000\002\001\001\000\004\031\076\001\001\000\012\016" +
    "\071\021\070\050\016\054\005\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\010\016\075\050" +
    "\016\054\005\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\064\010\053\012\111\013\021\015" +
    "\055\016\117\027\102\030\122\031\125\032\115\033\106" +
    "\034\107\037\113\040\112\042\103\044\124\045\123\046" +
    "\034\047\033\050\016\051\101\054\005\055\104\056\100" +
    "\057\120\060\116\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\010\045\167\046\034\047\033\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\045\164\046\034\047\033" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\010\045\152\046\034\047\033\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\010\045\141\046\034\047\033\001\001\000\064" +
    "\010\053\012\111\013\021\015\055\016\117\027\140\030" +
    "\122\031\125\032\115\033\106\034\107\037\113\040\112" +
    "\042\103\044\124\045\123\046\034\047\033\050\016\051" +
    "\101\054\005\055\104\056\100\057\120\060\116\001\001" +
    "\000\004\035\130\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\036\133\045\132\046\034" +
    "\047\033\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\045\137\046\034\047\033\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\031\142\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\051\150\001" +
    "\001\000\010\045\146\046\034\047\033\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\043\154\045\155\046\034" +
    "\047\033\001\001\000\010\045\161\046\034\047\033\001" +
    "\001\000\002\001\001\000\062\010\053\012\111\013\021" +
    "\015\055\016\117\030\157\031\125\032\115\033\106\034" +
    "\107\037\113\040\112\042\103\044\124\045\123\046\034" +
    "\047\033\050\016\051\101\054\005\055\104\056\100\057" +
    "\120\060\116\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\062\010\053\012\111\013\021\015" +
    "\055\016\117\030\163\031\125\032\115\033\106\034\107" +
    "\037\113\040\112\042\103\044\124\045\123\046\034\047" +
    "\033\050\016\051\101\054\005\055\104\056\100\057\120" +
    "\060\116\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\031\170\001\001" +
    "\000\004\041\172\001\001\000\006\031\173\040\174\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\010\045\176\046\034\047\033\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\050\016\054\213\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\031\216" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$SyntacticalAnalyser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$SyntacticalAnalyser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$SyntacticalAnalyser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

    return analyser.next_token();

    }


    private LexicalAnalyser analyser = (LexicalAnalyser) getScanner();

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$SyntacticalAnalyser$actions {


  private final SyntacticalAnalyser parser;

  /** Constructor */
  CUP$SyntacticalAnalyser$actions(SyntacticalAnalyser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$SyntacticalAnalyser$do_action_part00000000(
    int                        CUP$SyntacticalAnalyser$act_num,
    java_cup.runtime.lr_parser CUP$SyntacticalAnalyser$parser,
    java.util.Stack            CUP$SyntacticalAnalyser$stack,
    int                        CUP$SyntacticalAnalyser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$SyntacticalAnalyser$result;

      /* select the action based on the action number */
      switch (CUP$SyntacticalAnalyser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // Program ::= ImportList DeclarationList 
            {
              ProgramNode RESULT =null;
		List<String> imports = (List<String>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		DeclarationNode declarations = (DeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new ProgramNode(declarations, imports); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Program",0, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= Program EOF 
            {
              Object RESULT =null;
		ProgramNode start_val = (ProgramNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		RESULT = start_val;
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("$START",0, RESULT);
            }
          /* ACCEPT */
          CUP$SyntacticalAnalyser$parser.done_parsing();
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // ImportList ::= ImportList Import 
            {
              List<String> RESULT =null;
		List<String> imports = (List<String>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		String file = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 imports.add(file); RESULT = imports; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ImportList",1, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // ImportList ::= 
            {
              List<String> RESULT =null;
		 RESULT = new ArrayList<>(); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ImportList",1, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // Import ::= IMPORT FilePath END 
            {
              String RESULT =null;
		String path = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = path; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Import",2, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // FilePath ::= FilePath DIV IDENTIFIER 
            {
              String RESULT =null;
		String path = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-2)).value;
		String filename = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = path + "/" + filename; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FilePath",3, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // FilePath ::= IDENTIFIER 
            {
              String RESULT =null;
		String filename = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = filename; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FilePath",3, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // DeclarationList ::= Declaration DeclarationList 
            {
              DeclarationNode RESULT =null;
		DeclarationNode declaration = (DeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		DeclarationNode declarations = (DeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = declaration.linkedTo(declarations); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("DeclarationList",4, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // DeclarationList ::= 
            {
              DeclarationNode RESULT =null;
		 RESULT = null; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("DeclarationList",4, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // Declaration ::= GlobalVarConstDeclaration 
            {
              DeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = declaration; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Declaration",5, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // Declaration ::= FunctionDeclaration 
            {
              DeclarationNode RESULT =null;
		FunctionDeclarationNode declaration = (FunctionDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = declaration; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Declaration",5, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // Declaration ::= ClassDeclaration 
            {
              DeclarationNode RESULT =null;
		ClassDeclarationNode declaration = (ClassDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = declaration; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Declaration",5, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // GlobalVarConstDeclaration ::= VarDeclaration 
            {
              VarDeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = declaration; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("GlobalVarConstDeclaration",7, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // GlobalVarConstDeclaration ::= GlobalConstDeclaration END 
            {
              VarDeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = declaration; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("GlobalVarConstDeclaration",7, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // VarConstDeclaration ::= VarDeclaration 
            {
              VarDeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = declaration; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("VarConstDeclaration",8, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // VarConstDeclaration ::= LocalConstDeclaration END 
            {
              VarDeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = declaration; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("VarConstDeclaration",8, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // VarDeclaration ::= BaseVarDeclaration END 
            {
              VarDeclarationNode RESULT =null;
		Name declaration = (Name)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = new VarDeclarationNode(declaration); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("VarDeclaration",6, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // VarDeclaration ::= VarInitDeclaration END 
            {
              VarDeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = declaration; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("VarDeclaration",6, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // BaseVarDeclaration ::= Type VarId 
            {
              Name RESULT =null;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		String id = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new Name(id, type); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("BaseVarDeclaration",12, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // VarInitDeclaration ::= BaseVarDeclaration ASSIGNMENT Expression 
            {
              VarDeclarationNode RESULT =null;
		Name name = (Name)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-2)).value;
		ExpressionNode initialValue = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new VarDeclarationNode(name, initialValue); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("VarInitDeclaration",9, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // GlobalConstDeclaration ::= CONST Type GlobalConstId ASSIGNMENT Expression 
            {
              VarDeclarationNode RESULT =null;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-3)).value;
		String id = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-2)).value;
		ExpressionNode initialValue = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new VarDeclarationNode(new Name(id, type), initialValue, true, true); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("GlobalConstDeclaration",10, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // LocalConstDeclaration ::= CONST VarInitDeclaration 
            {
              VarDeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = declaration.constant(); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("LocalConstDeclaration",11, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // FunctionDeclaration ::= BaseVarDeclaration FunctionParameters BlockStatement 
            {
              FunctionDeclarationNode RESULT =null;
		Name name = (Name)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-2)).value;
		List<Name> parameters = (List<Name>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		BlockStatementNode block = (BlockStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new FunctionDeclarationNode(name, parameters, block); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FunctionDeclaration",13, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // FunctionParameters ::= PARENTH_L PARENTH_R 
            {
              List<Name> RESULT =null;
		 RESULT = new ArrayList<>(); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FunctionParameters",14, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // FunctionParameters ::= PARENTH_L ParameterList PARENTH_R 
            {
              List<Name> RESULT =null;
		List<Name> parameters = (List<Name>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = parameters; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FunctionParameters",14, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // ParameterList ::= BaseVarDeclaration 
            {
              List<Name> RESULT =null;
		Name parameter = (Name)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new ArrayList<Name>() {{ add(parameter); }}; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ParameterList",15, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // ParameterList ::= ParameterList COMMA BaseVarDeclaration 
            {
              List<Name> RESULT =null;
		List<Name> parameters = (List<Name>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-2)).value;
		Name parameter = (Name)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 parameters.add(parameter); RESULT = parameters; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ParameterList",15, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // ClassDeclaration ::= CLASS TypeName ClassBlock 
            {
              ClassDeclarationNode RESULT =null;
		String name = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		DeclarationNode block = (DeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new ClassDeclarationNode(name, block); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassDeclaration",16, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // ClassBlock ::= CURLY_L ClassElementList CURLY_R 
            {
              DeclarationNode RESULT =null;
		DeclarationNode contents = (DeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = contents; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassBlock",17, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // ClassElementList ::= ClassElement ClassElementList 
            {
              DeclarationNode RESULT =null;
		DeclarationNode element = (DeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		DeclarationNode elements = (DeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = element.linkedTo(elements); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassElementList",18, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // ClassElementList ::= 
            {
              DeclarationNode RESULT =null;
		 RESULT = null; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassElementList",18, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // ClassElement ::= VarConstDeclaration 
            {
              DeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = declaration; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassElement",19, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // ClassElement ::= ConstructorDeclaration 
            {
              DeclarationNode RESULT =null;
		ConstructorDeclarationNode declaration = (ConstructorDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = declaration; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassElement",19, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // ClassElement ::= FunctionDeclaration 
            {
              DeclarationNode RESULT =null;
		FunctionDeclarationNode declaration = (FunctionDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = declaration; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassElement",19, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // ConstructorDeclaration ::= CONSTRUCTOR FunctionParameters BlockStatement 
            {
              ConstructorDeclarationNode RESULT =null;
		List<Name> parameters = (List<Name>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		BlockStatementNode block = (BlockStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new ConstructorDeclarationNode(parameters, block); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstructorDeclaration",20, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // StatementList ::= Statement StatementList 
            {
              StatementNode RESULT =null;
		StatementNode statement = (StatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		StatementNode statements = (StatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = statement.linkedTo(statements); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("StatementList",21, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // StatementList ::= 
            {
              StatementNode RESULT =null;
		 RESULT = null; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("StatementList",21, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // Statement ::= VarDeclarationStatement 
            {
              StatementNode RESULT =null;
		VarDeclarationStatementNode statement = (VarDeclarationStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = statement; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement",22, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // Statement ::= AssignmentStatement 
            {
              StatementNode RESULT =null;
		AssignmentStatementNode statement = (AssignmentStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = statement; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement",22, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // Statement ::= FunctionCallStatement 
            {
              StatementNode RESULT =null;
		FunctionCallStatementNode statement = (FunctionCallStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = statement; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement",22, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // Statement ::= ReturnStatement 
            {
              StatementNode RESULT =null;
		ReturnStatementNode statement = (ReturnStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = statement; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement",22, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // Statement ::= IfElseStatement 
            {
              StatementNode RESULT =null;
		IfElseStatementNode statement = (IfElseStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = statement; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement",22, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // Statement ::= SwitchStatement 
            {
              StatementNode RESULT =null;
		SwitchStatementNode statement = (SwitchStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = statement; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement",22, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // Statement ::= WhileStatement 
            {
              StatementNode RESULT =null;
		WhileStatementNode statement = (WhileStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = statement; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement",22, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // Statement ::= BlockStatement 
            {
              StatementNode RESULT =null;
		BlockStatementNode statement = (BlockStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = statement; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement",22, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // BlockStatement ::= CURLY_L StatementList CURLY_R 
            {
              BlockStatementNode RESULT =null;
		StatementNode root = (StatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = new BlockStatementNode(root); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("BlockStatement",23, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // VarDeclarationStatement ::= VarConstDeclaration 
            {
              VarDeclarationStatementNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = declaration.asStatement(); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("VarDeclarationStatement",24, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // AssignmentStatement ::= Designator ASSIGNMENT Expression END 
            {
              AssignmentStatementNode RESULT =null;
		Designator designator = (Designator)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-3)).value;
		ExpressionNode expression = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = new AssignmentStatementNode(designator, expression); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("AssignmentStatement",25, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // FunctionCallStatement ::= Expression FunctionArguments END 
            {
              FunctionCallStatementNode RESULT =null;
		ExpressionNode function = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-2)).value;
		List<ExpressionNode> arguments = (List<ExpressionNode>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = new FunctionCallStatementNode(function, arguments); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FunctionCallStatement",26, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // FunctionArguments ::= PARENTH_L PARENTH_R 
            {
              List<ExpressionNode> RESULT =null;
		 RESULT = new ArrayList<>(); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FunctionArguments",27, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // FunctionArguments ::= PARENTH_L ArgumentList PARENTH_R 
            {
              List<ExpressionNode> RESULT =null;
		List<ExpressionNode> arguments = (List<ExpressionNode>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = arguments; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FunctionArguments",27, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // ArgumentList ::= Expression 
            {
              List<ExpressionNode> RESULT =null;
		ExpressionNode argument = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new ArrayList<ExpressionNode>() {{ add(argument); }}; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ArgumentList",28, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // ArgumentList ::= ArgumentList COMMA Expression 
            {
              List<ExpressionNode> RESULT =null;
		List<ExpressionNode> arguments = (List<ExpressionNode>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-2)).value;
		ExpressionNode argument = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 arguments.add(argument); RESULT = arguments; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ArgumentList",28, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // ReturnStatement ::= RETURN END 
            {
              ReturnStatementNode RESULT =null;
		 RESULT = new ReturnStatementNode(); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ReturnStatement",29, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // ReturnStatement ::= RETURN Expression END 
            {
              ReturnStatementNode RESULT =null;
		ExpressionNode expression = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = new ReturnStatementNode(expression); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ReturnStatement",29, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // IfElseStatement ::= IF Expression BlockStatement ElsePartStatement 
            {
              IfElseStatementNode RESULT =null;
		ExpressionNode condition = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-2)).value;
		BlockStatementNode ifBlock = (BlockStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		StatementNode elsePart = (StatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new IfElseStatementNode(condition, ifBlock, elsePart); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("IfElseStatement",30, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // ElsePartStatement ::= ELSE BlockStatement 
            {
              StatementNode RESULT =null;
		BlockStatementNode elseBlock = (BlockStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = elseBlock; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ElsePartStatement",31, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // ElsePartStatement ::= ELSE IfElseStatement 
            {
              StatementNode RESULT =null;
		IfElseStatementNode ifElse = (IfElseStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = ifElse; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ElsePartStatement",31, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // ElsePartStatement ::= 
            {
              StatementNode RESULT =null;
		 RESULT = null; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ElsePartStatement",31, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // SwitchStatement ::= SWITCH Expression CURLY_L SwitchCasesStatement CURLY_R 
            {
              SwitchStatementNode RESULT =null;
		ExpressionNode exp = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-3)).value;
		Map<ExpressionNode,StatementNode> cases = (Map<ExpressionNode,StatementNode>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = new SwitchStatementNode(exp, cases); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("SwitchStatement",32, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // SwitchCasesStatement ::= Expression ARROW Statement 
            {
              Map<ExpressionNode,StatementNode> RESULT =null;
		ExpressionNode exp = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-2)).value;
		StatementNode block = (StatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new HashMap<ExpressionNode, StatementNode>() {{ put(exp,
                          block);
                         }}; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("SwitchCasesStatement",33, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // SwitchCasesStatement ::= SwitchCasesStatement Expression ARROW Statement 
            {
              Map<ExpressionNode,StatementNode> RESULT =null;
		Map<ExpressionNode,StatementNode> cases = (Map<ExpressionNode,StatementNode>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-3)).value;
		ExpressionNode exp = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-2)).value;
		StatementNode block = (StatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 cases.put(exp, block); RESULT = cases; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("SwitchCasesStatement",33, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // WhileStatement ::= WHILE Expression BlockStatement 
            {
              WhileStatementNode RESULT =null;
		ExpressionNode condition = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		BlockStatementNode whileBlock = (BlockStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new WhileStatementNode(condition, whileBlock); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("WhileStatement",34, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // Expression ::= IDENTIFIER 
            {
              ExpressionNode RESULT =null;

              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Expression",35, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // Expression ::= ConstantExpression 
            {
              ExpressionNode RESULT =null;
		ConstantExpressionNode expression = (ConstantExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = expression; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Expression",35, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // Expression ::= ListConstantExpression 
            {
              ExpressionNode RESULT =null;

              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Expression",35, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // ConstantExpression ::= INT 
            {
              ConstantExpressionNode RESULT =null;
		String n = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = ConstantExpressionNode.fromInt(n); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression",36, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // ConstantExpression ::= REAL 
            {
              ConstantExpressionNode RESULT =null;
		String x = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = ConstantExpressionNode.fromFloat(x); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression",36, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // ConstantExpression ::= TRUE 
            {
              ConstantExpressionNode RESULT =null;
		String t = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = ConstantExpressionNode.fromBoolean(t); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression",36, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // ConstantExpression ::= FALSE 
            {
              ConstantExpressionNode RESULT =null;
		String f = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = ConstantExpressionNode.fromBoolean(f); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression",36, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // ConstantExpression ::= CHAR 
            {
              ConstantExpressionNode RESULT =null;
		String c = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = ConstantExpressionNode.fromChar(c); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression",36, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // ConstantExpression ::= NOTHING 
            {
              ConstantExpressionNode RESULT =null;
		 RESULT = ConstantExpressionNode.ofNothing(); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression",36, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // ConstantExpression ::= NULL 
            {
              ConstantExpressionNode RESULT =null;
		 RESULT = ConstantExpressionNode.ofNull(); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression",36, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // ConstantExpression ::= UNDERSCORE 
            {
              ConstantExpressionNode RESULT =null;
		 RESULT = ConstantExpressionNode.ofNull(); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression",36, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // ListConstantExpression ::= STRING 
            {
              Object RESULT =null;

              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ListConstantExpression",37, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // Type ::= TypeName 
            {
              Type RESULT =null;
		String name = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new Type(name); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Type",42, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // Type ::= TypeName LT Type GT 
            {
              Type RESULT =null;
		String name = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-3)).value;
		Type param = (Type)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = new Type(name, param); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Type",42, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // TypeName ::= IDENTIFIER 
            {
              String RESULT =null;
		String id = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = id; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("TypeName",38, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // VarId ::= IDENTIFIER 
            {
              String RESULT =null;
		String id = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = id; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("VarId",39, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // GlobalConstId ::= IDENTIFIER 
            {
              String RESULT =null;
		String id = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = id; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("GlobalConstId",40, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // Designator ::= VarId 
            {
              Designator RESULT =null;

              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Designator",43, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // Designator ::= ArrayAccess 
            {
              Designator RESULT =null;

              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Designator",43, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // Designator ::= FieldAccess 
            {
              Designator RESULT =null;

              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Designator",43, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // ArrayAccess ::= DesignableExpression SQUARE_L Expression SQUARE_R 
            {
              ExpressionNode RESULT =null;

              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ArrayAccess",44, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // FieldAccess ::= DesignableExpression POINT VarId 
            {
              ExpressionNode RESULT =null;

              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FieldAccess",45, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // DesignableExpression ::= VarId 
            {
              ExpressionNode RESULT =null;

              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("DesignableExpression",46, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$SyntacticalAnalyser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$SyntacticalAnalyser$do_action(
    int                        CUP$SyntacticalAnalyser$act_num,
    java_cup.runtime.lr_parser CUP$SyntacticalAnalyser$parser,
    java.util.Stack            CUP$SyntacticalAnalyser$stack,
    int                        CUP$SyntacticalAnalyser$top)
    throws java.lang.Exception
    {
              return CUP$SyntacticalAnalyser$do_action_part00000000(
                               CUP$SyntacticalAnalyser$act_num,
                               CUP$SyntacticalAnalyser$parser,
                               CUP$SyntacticalAnalyser$stack,
                               CUP$SyntacticalAnalyser$top);
    }
}

