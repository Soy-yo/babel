
//----------------------------------------------------
// The following code was generated by CUP v0.11b beta 20140220
// Mon Apr 27 17:02:01 CEST 2020
//----------------------------------------------------

package syntactical;

import lexical.LexicalAnalyser;
import syntactical.ast.*;

import java.util.*;

/**
 * CUP v0.11b beta 20140220 generated parser.
 *
 * @version Mon Apr 27 17:02:01 CEST 2020
 */
public class SyntacticalAnalyser extends java_cup.runtime.lr_parser {

    /** Default constructor. */
    public SyntacticalAnalyser() {
        super();
    }

    /** Constructor which sets the default scanner. */
    public SyntacticalAnalyser(java_cup.runtime.Scanner s) {
        super(s);
    }

    /** Constructor which sets the default scanner. */
    public SyntacticalAnalyser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {
        super(s, sf);
    }

    /** Production table. */
    protected static final short _production_table[][] =
            unpackFromStrings(new String[]{
                    "\000\137\000\002\002\004\000\002\002\004\000\002\003" +
                            "\004\000\002\003\002\000\002\004\005\000\002\005\005" +
                            "\000\002\005\003\000\002\006\003\000\002\006\003\000" +
                            "\002\006\003\000\002\007\004\000\002\007\002\000\002" +
                            "\010\003\000\002\010\003\000\002\010\003\000\002\012" +
                            "\003\000\002\012\004\000\002\013\003\000\002\013\004" +
                            "\000\002\011\004\000\002\011\004\000\002\017\004\000" +
                            "\002\014\005\000\002\015\007\000\002\016\004\000\002" +
                            "\020\005\000\002\021\004\000\002\021\005\000\002\022" +
                            "\003\000\002\022\005\000\002\023\005\000\002\024\005" +
                            "\000\002\025\004\000\002\025\002\000\002\026\003\000" +
                            "\002\026\003\000\002\026\003\000\002\027\005\000\002" +
                            "\030\004\000\002\030\002\000\002\031\003\000\002\031" +
                            "\003\000\002\031\003\000\002\031\003\000\002\031\003" +
                            "\000\002\031\003\000\002\031\003\000\002\031\003\000" +
                            "\002\031\003\000\002\032\005\000\002\033\003\000\002" +
                            "\034\006\000\002\040\004\000\002\040\005\000\002\041" +
                            "\006\000\002\042\004\000\002\042\004\000\002\042\002" +
                            "\000\002\043\007\000\002\044\005\000\002\044\006\000" +
                            "\002\045\005\000\002\046\007\000\002\047\003\000\002" +
                            "\047\003\000\002\047\003\000\002\050\003\000\002\050" +
                            "\003\000\002\050\003\000\002\050\003\000\002\050\003" +
                            "\000\002\050\003\000\002\050\003\000\002\050\003\000" +
                            "\002\051\003\000\002\051\004\000\002\051\005\000\002" +
                            "\052\003\000\002\052\005\000\002\053\004\000\002\053" +
                            "\005\000\002\054\003\000\002\054\005\000\002\055\003" +
                            "\000\002\055\003\000\002\057\003\000\002\057\006\000" +
                            "\002\056\003\000\002\056\003\000\002\060\003\000\002" +
                            "\060\003\000\002\060\003\000\002\061\006\000\002\062" +
                            "\005\000\002\063\003"});

    /** Access to production table. */
    public short[][] production_table() {
        return _production_table;
    }

    /** Parse-action table. */
    protected static final short[][] _action_table =
            unpackFromStrings(new String[]{
                    "\000\236\000\016\002\ufffe\013\ufffe\014\ufffe\061\ufffe\062" +
                            "\ufffe\063\ufffe\001\002\000\004\002\240\001\002\000\016" +
                            "\002\ufff6\013\026\014\025\061\022\062\020\063\024\001" +
                            "\002\000\004\060\237\001\002\000\016\002\uffff\013\uffff" +
                            "\014\uffff\061\uffff\062\uffff\063\uffff\001\002\000\004\057" +
                            "\236\001\002\000\014\002\ufff3\013\ufff3\014\ufff3\061\ufff3" +
                            "\062\ufff3\001\002\000\014\002\ufff6\013\026\014\025\061" +
                            "\022\062\020\001\002\000\014\002\ufff2\013\ufff2\014\ufff2" +
                            "\061\ufff2\062\ufff2\001\002\000\004\002\001\001\002\000" +
                            "\010\020\110\053\067\057\164\001\002\000\014\002\ufff5" +
                            "\013\ufff5\014\ufff5\061\ufff5\062\ufff5\001\002\000\012\045" +
                            "\230\047\uffac\060\uffac\061\uffac\001\002\000\014\024\uffaa" +
                            "\045\uffaa\047\uffaa\060\uffaa\061\uffaa\001\002\000\014\002" +
                            "\ufff4\013\ufff4\014\ufff4\061\ufff4\062\ufff4\001\002\000\014" +
                            "\024\uffa9\045\uffa9\047\uffa9\060\uffa9\061\uffa9\001\002\000" +
                            "\004\057\227\001\002\000\010\060\222\061\220\062\223" +
                            "\001\002\000\006\061\022\062\020\001\002\000\006\061" +
                            "\022\062\020\001\002\000\004\061\030\001\002\000\004" +
                            "\053\031\001\002\000\030\017\050\022\044\024\036\064" +
                            "\032\065\046\066\047\067\042\070\037\071\045\072\033" +
                            "\073\040\001\002\000\016\023\uffbf\024\uffbf\025\uffbf\026" +
                            "\uffbf\031\uffbf\057\uffbf\001\002\000\016\023\uffba\024\uffba" +
                            "\025\uffba\026\uffba\031\uffba\057\uffba\001\002\000\016\023" +
                            "\uffc2\024\uffc2\025\uffc2\026\uffc2\031\uffc2\057\uffc2\001\002" +
                            "\000\016\023\uffc1\024\uffc1\025\uffc1\026\uffc1\031\uffc1\057" +
                            "\uffc1\001\002\000\012\013\065\025\060\061\022\062\020" +
                            "\001\002\000\016\023\uffbd\024\uffbd\025\uffbd\026\uffbd\031" +
                            "\uffbd\057\uffbd\001\002\000\016\023\uffb9\024\uffb9\025\uffb9" +
                            "\026\uffb9\031\uffb9\057\uffb9\001\002\000\016\023\uffc0\024" +
                            "\uffc0\025\uffc0\026\uffc0\031\uffc0\057\uffc0\001\002\000\016" +
                            "\023\uffb7\024\uffb7\025\uffb7\026\uffb7\031\uffb7\057\uffb7\001" +
                            "\002\000\004\057\uffea\001\002\000\032\017\050\022\044" +
                            "\023\052\024\036\064\032\065\046\066\047\067\042\070" +
                            "\037\071\045\072\033\073\040\001\002\000\016\023\uffbc" +
                            "\024\uffbc\025\uffbc\026\uffbc\031\uffbc\057\uffbc\001\002\000" +
                            "\016\023\uffbe\024\uffbe\025\uffbe\026\uffbe\031\uffbe\057\uffbe" +
                            "\001\002\000\016\023\uffbb\024\uffbb\025\uffbb\026\uffbb\031" +
                            "\uffbb\057\uffbb\001\002\000\016\023\uffb8\024\uffb8\025\uffb8" +
                            "\026\uffb8\031\uffb8\057\uffb8\001\002\000\006\023\055\031" +
                            "\054\001\002\000\016\023\uffb6\024\uffb6\025\uffb6\026\uffb6" +
                            "\031\uffb6\057\uffb6\001\002\000\006\023\uffb4\031\uffb4\001" +
                            "\002\000\030\017\050\022\044\024\036\064\032\065\046" +
                            "\066\047\067\042\070\037\071\045\072\033\073\040\001" +
                            "\002\000\016\023\uffb5\024\uffb5\025\uffb5\026\uffb5\031\uffb5" +
                            "\057\uffb5\001\002\000\006\023\uffb3\031\uffb3\001\002\000" +
                            "\006\025\uffb0\031\072\001\002\000\016\023\uffb2\024\uffb2" +
                            "\025\uffb2\026\uffb2\031\uffb2\057\uffb2\001\002\000\004\025" +
                            "\071\001\002\000\004\053\067\001\002\000\006\025\uffad" +
                            "\031\uffad\001\002\000\006\025\uffae\031\uffae\001\002\000" +
                            "\006\061\022\062\020\001\002\000\010\025\uffe9\031\uffe9" +
                            "\057\uffe9\001\002\000\030\017\050\022\044\024\036\064" +
                            "\032\065\046\066\047\067\042\070\037\071\045\072\033" +
                            "\073\040\001\002\000\010\025\uffeb\031\uffeb\057\uffeb\001" +
                            "\002\000\016\023\uffb1\024\uffb1\025\uffb1\026\uffb1\031\uffb1" +
                            "\057\uffb1\001\002\000\010\013\065\061\022\062\020\001" +
                            "\002\000\004\025\uffaf\001\002\000\004\024\075\001\002" +
                            "\000\014\013\065\015\106\025\uffe0\061\022\062\020\001" +
                            "\002\000\014\002\uffe3\013\uffe3\014\uffe3\061\uffe3\062\uffe3" +
                            "\001\002\000\014\013\065\015\106\025\uffe0\061\022\062" +
                            "\020\001\002\000\014\013\uffde\015\uffde\025\uffde\061\uffde" +
                            "\062\uffde\001\002\000\056\004\ufff0\006\ufff0\007\ufff0\010" +
                            "\ufff0\012\ufff0\013\ufff0\015\ufff0\017\ufff0\022\ufff0\024\ufff0" +
                            "\025\ufff0\060\ufff0\061\ufff0\062\ufff0\064\ufff0\065\ufff0\066" +
                            "\ufff0\067\ufff0\070\ufff0\071\ufff0\072\ufff0\073\ufff0\001\002" +
                            "\000\014\013\uffdf\015\uffdf\025\uffdf\061\uffdf\062\uffdf\001" +
                            "\002\000\004\057\215\001\002\000\004\025\214\001\002" +
                            "\000\014\013\uffdd\015\uffdd\025\uffdd\061\uffdd\062\uffdd\001" +
                            "\002\000\004\020\110\001\002\000\004\024\120\001\002" +
                            "\000\010\021\113\061\022\062\020\001\002\000\006\021" +
                            "\115\031\114\001\002\000\006\021\uffe5\031\uffe5\001\002" +
                            "\000\004\024\uffe7\001\002\000\006\061\022\062\020\001" +
                            "\002\000\004\024\uffe6\001\002\000\006\021\uffe4\031\uffe4" +
                            "\001\002\000\014\013\uffdc\015\uffdc\025\uffdc\061\uffdc\062" +
                            "\uffdc\001\002\000\030\004\135\006\132\007\144\010\124" +
                            "\012\130\013\065\024\120\025\uffda\060\127\061\022\062" +
                            "\020\001\002\000\004\053\211\001\002\000\054\004\uffd6" +
                            "\006\uffd6\007\uffd6\010\uffd6\012\uffd6\013\uffd6\017\uffd6\022" +
                            "\uffd6\024\uffd6\025\uffd6\060\uffd6\061\uffd6\062\uffd6\064\uffd6" +
                            "\065\uffd6\066\uffd6\067\uffd6\070\uffd6\071\uffd6\072\uffd6\073" +
                            "\uffd6\001\002\000\054\004\uffd8\006\uffd8\007\uffd8\010\uffd8" +
                            "\012\uffd8\013\uffd8\017\uffd8\022\uffd8\024\uffd8\025\uffd8\060" +
                            "\uffd8\061\uffd8\062\uffd8\064\uffd8\065\uffd8\066\uffd8\067\uffd8" +
                            "\070\uffd8\071\uffd8\072\uffd8\073\uffd8\001\002\000\030\017" +
                            "\050\022\044\024\036\064\032\065\046\066\047\067\042" +
                            "\070\037\071\045\072\033\073\040\001\002\000\054\004" +
                            "\uffcf\006\uffcf\007\uffcf\010\uffcf\012\uffcf\013\uffcf\017\uffcf" +
                            "\022\uffcf\024\uffcf\025\uffcf\060\uffcf\061\uffcf\062\uffcf\064" +
                            "\uffcf\065\uffcf\066\uffcf\067\uffcf\070\uffcf\071\uffcf\072\uffcf" +
                            "\073\uffcf\001\002\000\054\004\uffd9\006\uffd9\007\uffd9\010" +
                            "\uffd9\012\uffd9\013\uffd9\017\uffd9\022\uffd9\024\uffd9\025\uffd9" +
                            "\060\uffd9\061\uffd9\062\uffd9\064\uffd9\065\uffd9\066\uffd9\067" +
                            "\uffd9\070\uffd9\071\uffd9\072\uffd9\073\uffd9\001\002\000\010" +
                            "\022\uffa3\030\uffa3\053\uffa8\001\002\000\032\017\050\022" +
                            "\044\024\036\057\205\064\032\065\046\066\047\067\042" +
                            "\070\037\071\045\072\033\073\040\001\002\000\006\022" +
                            "\200\030\177\001\002\000\030\017\050\022\044\024\036" +
                            "\064\032\065\046\066\047\067\042\070\037\071\045\072" +
                            "\033\073\040\001\002\000\054\004\uffd5\006\uffd5\007\uffd5" +
                            "\010\uffd5\012\uffd5\013\uffd5\017\uffd5\022\uffd5\024\uffd5\025" +
                            "\uffd5\060\uffd5\061\uffd5\062\uffd5\064\uffd5\065\uffd5\066\uffd5" +
                            "\067\uffd5\070\uffd5\071\uffd5\072\uffd5\073\uffd5\001\002\000" +
                            "\006\053\067\057\164\001\002\000\030\017\050\022\044" +
                            "\024\036\064\032\065\046\066\047\067\042\070\037\071" +
                            "\045\072\033\073\040\001\002\000\054\004\uffd2\006\uffd2" +
                            "\007\uffd2\010\uffd2\012\uffd2\013\uffd2\017\uffd2\022\uffd2\024" +
                            "\uffd2\025\uffd2\060\uffd2\061\uffd2\062\uffd2\064\uffd2\065\uffd2" +
                            "\066\uffd2\067\uffd2\070\uffd2\071\uffd2\072\uffd2\073\uffd2\001" +
                            "\002\000\054\004\uffd4\006\uffd4\007\uffd4\010\uffd4\012\uffd4" +
                            "\013\uffd4\017\uffd4\022\uffd4\024\uffd4\025\uffd4\060\uffd4\061" +
                            "\uffd4\062\uffd4\064\uffd4\065\uffd4\066\uffd4\067\uffd4\070\uffd4" +
                            "\071\uffd4\072\uffd4\073\uffd4\001\002\000\054\004\uffd3\006" +
                            "\uffd3\007\uffd3\010\uffd3\012\uffd3\013\uffd3\017\uffd3\022\uffd3" +
                            "\024\uffd3\025\uffd3\060\uffd3\061\uffd3\062\uffd3\064\uffd3\065" +
                            "\uffd3\066\uffd3\067\uffd3\070\uffd3\071\uffd3\072\uffd3\073\uffd3" +
                            "\001\002\000\054\004\uffd7\006\uffd7\007\uffd7\010\uffd7\012" +
                            "\uffd7\013\uffd7\017\uffd7\022\uffd7\024\uffd7\025\uffd7\060\uffd7" +
                            "\061\uffd7\062\uffd7\064\uffd7\065\uffd7\066\uffd7\067\uffd7\070" +
                            "\uffd7\071\uffd7\072\uffd7\073\uffd7\001\002\000\004\053\uffa7" +
                            "\001\002\000\030\004\135\006\132\007\144\010\124\012" +
                            "\130\013\065\024\120\025\uffda\060\127\061\022\062\020" +
                            "\001\002\000\006\061\022\062\020\001\002\000\004\025" +
                            "\150\001\002\000\054\004\uffd1\006\uffd1\007\uffd1\010\uffd1" +
                            "\012\uffd1\013\uffd1\017\uffd1\022\uffd1\024\uffd1\025\uffd1\060" +
                            "\uffd1\061\uffd1\062\uffd1\064\uffd1\065\uffd1\066\uffd1\067\uffd1" +
                            "\070\uffd1\071\uffd1\072\uffd1\073\uffd1\001\002\000\004\053" +
                            "\uffa6\001\002\000\064\002\uffd0\004\uffd0\005\uffd0\006\uffd0" +
                            "\007\uffd0\010\uffd0\012\uffd0\013\uffd0\014\uffd0\015\uffd0\017" +
                            "\uffd0\022\uffd0\024\uffd0\025\uffd0\060\uffd0\061\uffd0\062\uffd0" +
                            "\064\uffd0\065\uffd0\066\uffd0\067\uffd0\070\uffd0\071\uffd0\072" +
                            "\uffd0\073\uffd0\001\002\000\004\011\152\001\002\000\030" +
                            "\017\050\022\044\024\036\064\032\065\046\066\047\067" +
                            "\042\070\037\071\045\072\033\073\040\001\002\000\004" +
                            "\024\120\001\002\000\054\004\uffc3\006\uffc3\007\uffc3\010" +
                            "\uffc3\012\uffc3\013\uffc3\017\uffc3\022\uffc3\024\uffc3\025\uffc3" +
                            "\060\uffc3\061\uffc3\062\uffc3\064\uffc3\065\uffc3\066\uffc3\067" +
                            "\uffc3\070\uffc3\071\uffc3\072\uffc3\073\uffc3\001\002\000\004" +
                            "\025\uffdb\001\002\000\004\024\120\001\002\000\056\004" +
                            "\uffc8\005\160\006\uffc8\007\uffc8\010\uffc8\012\uffc8\013\uffc8" +
                            "\017\uffc8\022\uffc8\024\uffc8\025\uffc8\060\uffc8\061\uffc8\062" +
                            "\uffc8\064\uffc8\065\uffc8\066\uffc8\067\uffc8\070\uffc8\071\uffc8" +
                            "\072\uffc8\073\uffc8\001\002\000\006\004\135\024\120\001" +
                            "\002\000\054\004\uffcb\006\uffcb\007\uffcb\010\uffcb\012\uffcb" +
                            "\013\uffcb\017\uffcb\022\uffcb\024\uffcb\025\uffcb\060\uffcb\061" +
                            "\uffcb\062\uffcb\064\uffcb\065\uffcb\066\uffcb\067\uffcb\070\uffcb" +
                            "\071\uffcb\072\uffcb\073\uffcb\001\002\000\054\004\uffca\006" +
                            "\uffca\007\uffca\010\uffca\012\uffca\013\uffca\017\uffca\022\uffca" +
                            "\024\uffca\025\uffca\060\uffca\061\uffca\062\uffca\064\uffca\065" +
                            "\uffca\066\uffca\067\uffca\070\uffca\071\uffca\072\uffca\073\uffca" +
                            "\001\002\000\054\004\uffc9\006\uffc9\007\uffc9\010\uffc9\012" +
                            "\uffc9\013\uffc9\017\uffc9\022\uffc9\024\uffc9\025\uffc9\060\uffc9" +
                            "\061\uffc9\062\uffc9\064\uffc9\065\uffc9\066\uffc9\067\uffc9\070" +
                            "\uffc9\071\uffc9\072\uffc9\073\uffc9\001\002\000\062\002\uffee" +
                            "\004\uffee\006\uffee\007\uffee\010\uffee\012\uffee\013\uffee\014" +
                            "\uffee\015\uffee\017\uffee\022\uffee\024\uffee\025\uffee\060\uffee" +
                            "\061\uffee\062\uffee\064\uffee\065\uffee\066\uffee\067\uffee\070" +
                            "\uffee\071\uffee\072\uffee\073\uffee\001\002\000\004\024\166" +
                            "\001\002\000\022\017\050\064\032\065\046\066\047\070" +
                            "\037\071\045\072\033\073\040\001\002\000\004\026\175" +
                            "\001\002\000\032\017\050\022\044\024\036\025\171\064" +
                            "\032\065\046\066\047\067\042\070\037\071\045\072\033" +
                            "\073\040\001\002\000\054\004\uffc7\006\uffc7\007\uffc7\010" +
                            "\uffc7\012\uffc7\013\uffc7\017\uffc7\022\uffc7\024\uffc7\025\uffc7" +
                            "\060\uffc7\061\uffc7\062\uffc7\064\uffc7\065\uffc7\066\uffc7\067" +
                            "\uffc7\070\uffc7\071\uffc7\072\uffc7\073\uffc7\001\002\000\004" +
                            "\026\173\001\002\000\026\004\135\006\132\007\144\010" +
                            "\124\012\130\013\065\024\120\060\127\061\022\062\020" +
                            "\001\002\000\032\017\uffc5\022\uffc5\024\uffc5\025\uffc5\064" +
                            "\uffc5\065\uffc5\066\uffc5\067\uffc5\070\uffc5\071\uffc5\072\uffc5" +
                            "\073\uffc5\001\002\000\026\004\135\006\132\007\144\010" +
                            "\124\012\130\013\065\024\120\060\127\061\022\062\020" +
                            "\001\002\000\032\017\uffc6\022\uffc6\024\uffc6\025\uffc6\064" +
                            "\uffc6\065\uffc6\066\uffc6\067\uffc6\070\uffc6\071\uffc6\072\uffc6" +
                            "\073\uffc6\001\002\000\004\060\203\001\002\000\030\017" +
                            "\050\022\044\024\036\064\032\065\046\066\047\067\042" +
                            "\070\037\071\045\072\033\073\040\001\002\000\004\023" +
                            "\202\001\002\000\004\053\uffa5\001\002\000\004\053\uffa4" +
                            "\001\002\000\004\057\206\001\002\000\054\004\uffcd\006" +
                            "\uffcd\007\uffcd\010\uffcd\012\uffcd\013\uffcd\017\uffcd\022\uffcd" +
                            "\024\uffcd\025\uffcd\060\uffcd\061\uffcd\062\uffcd\064\uffcd\065" +
                            "\uffcd\066\uffcd\067\uffcd\070\uffcd\071\uffcd\072\uffcd\073\uffcd" +
                            "\001\002\000\054\004\uffcc\006\uffcc\007\uffcc\010\uffcc\012" +
                            "\uffcc\013\uffcc\017\uffcc\022\uffcc\024\uffcc\025\uffcc\060\uffcc" +
                            "\061\uffcc\062\uffcc\064\uffcc\065\uffcc\066\uffcc\067\uffcc\070" +
                            "\uffcc\071\uffcc\072\uffcc\073\uffcc\001\002\000\004\024\120" +
                            "\001\002\000\054\004\uffc4\006\uffc4\007\uffc4\010\uffc4\012" +
                            "\uffc4\013\uffc4\017\uffc4\022\uffc4\024\uffc4\025\uffc4\060\uffc4" +
                            "\061\uffc4\062\uffc4\064\uffc4\065\uffc4\066\uffc4\067\uffc4\070" +
                            "\uffc4\071\uffc4\072\uffc4\073\uffc4\001\002\000\030\017\050" +
                            "\022\044\024\036\064\032\065\046\066\047\067\042\070" +
                            "\037\071\045\072\033\073\040\001\002\000\004\057\213" +
                            "\001\002\000\054\004\uffce\006\uffce\007\uffce\010\uffce\012" +
                            "\uffce\013\uffce\017\uffce\022\uffce\024\uffce\025\uffce\060\uffce" +
                            "\061\uffce\062\uffce\064\uffce\065\uffce\066\uffce\067\uffce\070" +
                            "\uffce\071\uffce\072\uffce\073\uffce\001\002\000\014\002\uffe2" +
                            "\013\uffe2\014\uffe2\061\uffe2\062\uffe2\001\002\000\056\004" +
                            "\uffef\006\uffef\007\uffef\010\uffef\012\uffef\013\uffef\015\uffef" +
                            "\017\uffef\022\uffef\024\uffef\025\uffef\060\uffef\061\uffef\062" +
                            "\uffef\064\uffef\065\uffef\066\uffef\067\uffef\070\uffef\071\uffef" +
                            "\072\uffef\073\uffef\001\002\000\004\025\uffe1\001\002\000" +
                            "\006\041\ufffb\057\ufffb\001\002\000\006\041\ufff9\057\ufff9" +
                            "\001\002\000\006\041\224\057\225\001\002\000\006\041" +
                            "\ufffa\057\ufffa\001\002\000\006\041\ufff8\057\ufff8\001\002" +
                            "\000\010\060\222\061\220\062\223\001\002\000\016\002" +
                            "\ufffd\013\ufffd\014\ufffd\061\ufffd\062\ufffd\063\ufffd\001\002" +
                            "\000\006\041\ufffc\057\ufffc\001\002\000\062\002\uffed\004" +
                            "\uffed\006\uffed\007\uffed\010\uffed\012\uffed\013\uffed\014\uffed" +
                            "\015\uffed\017\uffed\022\uffed\024\uffed\025\uffed\060\uffed\061" +
                            "\uffed\062\uffed\064\uffed\065\uffed\066\uffed\067\uffed\070\uffed" +
                            "\071\uffed\072\uffed\073\uffed\001\002\000\006\061\022\062" +
                            "\020\001\002\000\004\047\232\001\002\000\010\047\uffab" +
                            "\060\uffab\061\uffab\001\002\000\004\024\120\001\002\000" +
                            "\020\002\uffe8\013\uffe8\014\uffe8\015\uffe8\025\uffe8\061\uffe8" +
                            "\062\uffe8\001\002\000\004\002\ufff7\001\002\000\014\002" +
                            "\ufff1\013\ufff1\014\ufff1\061\ufff1\062\ufff1\001\002\000\016" +
                            "\011\uffec\020\uffec\021\uffec\031\uffec\053\uffec\057\uffec\001" +
                            "\002\000\004\002\000\001\002"});

    /** Access to parse-action table. */
    public short[][] action_table() {
        return _action_table;
    }

    /** <code>reduce_goto</code> table. */
    protected static final short[][] _reduce_table =
            unpackFromStrings(new String[]{
                    "\000\236\000\006\002\003\003\004\001\001\000\002\001" +
                            "\001\000\032\004\006\007\013\010\011\011\012\012\015" +
                            "\014\022\015\007\017\014\020\020\023\010\056\016\057" +
                            "\005\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\030\007\234\010\011\011" +
                            "\012\012\015\014\022\015\007\017\014\020\020\023\010" +
                            "\056\016\057\005\001\001\000\002\001\001\000\002\001" +
                            "\001\000\004\021\232\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\006\005\220\006\216\001\001" +
                            "\000\004\056\073\001\001\000\006\056\016\057\026\001" +
                            "\001\000\002\001\001\000\002\001\001\000\012\047\042" +
                            "\050\033\051\034\053\040\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\020" +
                            "\014\063\016\062\017\061\054\060\055\056\056\016\057" +
                            "\005\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\014\047" +
                            "\052\050\033\051\034\052\050\053\040\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\012\047\055\050\033\051\034\053\040\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\012\014\065\017\061\056\016" +
                            "\057\005\001\001\000\002\001\001\000\012\047\067\050" +
                            "\033\051\034\053\040\001\001\000\002\001\001\000\002" +
                            "\001\001\000\020\014\063\016\062\017\061\054\072\055" +
                            "\056\056\016\057\005\001\001\000\002\001\001\000\004" +
                            "\024\075\001\001\000\030\011\100\013\101\014\022\016" +
                            "\102\017\014\020\104\025\103\026\076\027\077\056\016" +
                            "\057\005\001\001\000\002\001\001\000\030\011\100\013" +
                            "\101\014\022\016\102\017\014\020\104\025\215\026\076" +
                            "\027\077\056\016\057\005\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\004\021\106\001\001\000" +
                            "\004\032\116\001\001\000\012\017\111\022\110\056\016" +
                            "\057\005\001\001\000\002\001\001\000\002\001\001\000" +
                            "\002\001\001\000\010\017\115\056\016\057\005\001\001" +
                            "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
                            "\056\011\100\013\124\014\022\016\102\017\133\030\144" +
                            "\031\142\032\145\033\125\034\122\035\140\040\121\041" +
                            "\132\043\136\045\137\046\135\056\016\057\005\060\120" +
                            "\061\141\062\146\063\130\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\012\047\206\050\033" +
                            "\051\034\053\040\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\012\047\203\050\033\051\034" +
                            "\053\040\001\001\000\002\001\001\000\012\047\164\050" +
                            "\033\051\034\053\040\001\001\000\002\001\001\000\002" +
                            "\001\001\000\012\047\155\050\033\051\034\053\040\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\002\001\001\000\002\001\001\000\056\011\100\013" +
                            "\124\014\022\016\102\017\133\030\154\031\142\032\145" +
                            "\033\125\034\122\035\140\040\121\041\132\043\136\045" +
                            "\137\046\135\056\016\057\005\060\120\061\141\062\146" +
                            "\063\130\001\001\000\010\017\150\056\016\057\005\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\002\001\001\000\002\001\001\000\012\047\152\050" +
                            "\033\051\034\053\040\001\001\000\004\032\153\001\001" +
                            "\000\002\001\001\000\002\001\001\000\004\032\156\001" +
                            "\001\000\004\042\160\001\001\000\006\032\161\041\162" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\006\044\167" +
                            "\050\166\001\001\000\002\001\001\000\012\047\171\050" +
                            "\033\051\034\053\040\001\001\000\002\001\001\000\002" +
                            "\001\001\000\054\011\100\013\124\014\022\016\102\017" +
                            "\133\031\173\032\145\033\125\034\122\035\140\040\121" +
                            "\041\132\043\136\045\137\046\135\056\016\057\005\060" +
                            "\120\061\141\062\146\063\130\001\001\000\002\001\001" +
                            "\000\054\011\100\013\124\014\022\016\102\017\133\031" +
                            "\175\032\145\033\125\034\122\035\140\040\121\041\132" +
                            "\043\136\045\137\046\135\056\016\057\005\060\120\061" +
                            "\141\062\146\063\130\001\001\000\002\001\001\000\002" +
                            "\001\001\000\012\047\200\050\033\051\034\053\040\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
                            "\004\032\207\001\001\000\002\001\001\000\012\047\211" +
                            "\050\033\051\034\053\040\001\001\000\002\001\001\000" +
                            "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\004\006\225" +
                            "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
                            "\001\000\006\056\016\057\230\001\001\000\002\001\001" +
                            "\000\002\001\001\000\004\032\233\001\001\000\002\001" +
                            "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                            "\000\002\001\001"});

    /** Access to <code>reduce_goto</code> table. */
    public short[][] reduce_table() {
        return _reduce_table;
    }

    /** Instance of action encapsulation class. */
    protected CUP$SyntacticalAnalyser$actions action_obj;

    /** Action encapsulation object initializer. */
    protected void init_actions() {
        action_obj = new CUP$SyntacticalAnalyser$actions(this);
    }

    /** Invoke a user supplied parse action. */
    public java_cup.runtime.Symbol do_action(
            int act_num,
            java_cup.runtime.lr_parser parser,
            java.util.Stack stack,
            int top)
            throws java.lang.Exception {
        /* call code in generated class */
        return action_obj.CUP$SyntacticalAnalyser$do_action(act_num, parser, stack, top);
    }

    /** Indicates start state. */
    public int start_state() {
        return 0;
    }

    /** Indicates start production. */
    public int start_production() {
        return 1;
    }

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

    return analyser.next_token();

    }


    private LexicalAnalyser analyser = (LexicalAnalyser) getScanner();

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$SyntacticalAnalyser$actions {


  private final SyntacticalAnalyser parser;

  /** Constructor */
  CUP$SyntacticalAnalyser$actions(SyntacticalAnalyser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$SyntacticalAnalyser$do_action_part00000000(
    int                        CUP$SyntacticalAnalyser$act_num,
    java_cup.runtime.lr_parser CUP$SyntacticalAnalyser$parser,
    java.util.Stack            CUP$SyntacticalAnalyser$stack,
    int                        CUP$SyntacticalAnalyser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$SyntacticalAnalyser$result;

      /* select the action based on the action number */
      switch (CUP$SyntacticalAnalyser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // Program ::= ImportList DeclarationList 
            {
              ProgramNode RESULT =null;
		List<String> imports = (List<String>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		DeclarationNode declarations = (DeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = new ProgramNode(declarations, imports); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Program",0, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= Program EOF 
            {
              Object RESULT =null;
		ProgramNode start_val = (ProgramNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		RESULT = start_val;
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("$START",0, RESULT);
            }
          /* ACCEPT */
          CUP$SyntacticalAnalyser$parser.done_parsing();
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // ImportList ::= ImportList Import 
            {
              List<String> RESULT =null;
		List<String> imports = (List<String>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		String file = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 imports.add(file); RESULT = imports; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ImportList",1, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // ImportList ::= 
            {
              List<String> RESULT =null;
		 RESULT = new ArrayList<>(); 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ImportList",1, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // Import ::= IMPORT FilePath END 
            {
              String RESULT =null;
		String path = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		 RESULT = path; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Import",2, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 5: // FilePath ::= FilePath DIV Filename
            {
              String RESULT =null;
		String path = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-2)).value;
		String filename = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
		 RESULT = path + "/" + filename; 
              CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FilePath",3, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 6: // FilePath ::= Filename
            {
                String RESULT = null;
                String filename = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = filename;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FilePath", 3, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 7: // Filename ::= IDENTIFIER
            {
                String RESULT = null;
                String name = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = name;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Filename", 4, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 8: // Filename ::= GLOBAL
            {
                String RESULT = null;
                String name = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = name;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Filename", 4, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 9: // Filename ::= TYPE
            {
                String RESULT = null;
                String name = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = name;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Filename", 4, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 10: // DeclarationList ::= Declaration DeclarationList
            {
                DeclarationNode RESULT = null;
                DeclarationNode declaration = (DeclarationNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 1)).value;
                DeclarationNode declarations = (DeclarationNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = declaration.linkedTo(declarations);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("DeclarationList", 5, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 11: // DeclarationList ::=
            {
              DeclarationNode RESULT =null;
                RESULT = null;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("DeclarationList", 5, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 12: // Declaration ::= GlobalVarConstDeclaration
            {
              DeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = declaration;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Declaration", 6, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 13: // Declaration ::= FunctionDeclaration
            {
              DeclarationNode RESULT =null;
		FunctionDeclarationNode declaration = (FunctionDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = declaration;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Declaration", 6, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 14: // Declaration ::= ClassDeclaration
            {
              DeclarationNode RESULT =null;
		ClassDeclarationNode declaration = (ClassDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = declaration;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Declaration", 6, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 15: // GlobalVarConstDeclaration ::= VarDeclaration
            {
              VarDeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = declaration;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("GlobalVarConstDeclaration", 8, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 16: // GlobalVarConstDeclaration ::= GlobalConstDeclaration END
            {
              VarDeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
                RESULT = declaration;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("GlobalVarConstDeclaration", 8, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 17: // VarConstDeclaration ::= VarDeclaration
            {
              VarDeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = declaration;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("VarConstDeclaration", 9, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 18: // VarConstDeclaration ::= LocalConstDeclaration END
            {
              VarDeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
                RESULT = declaration;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("VarConstDeclaration", 9, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 19: // VarDeclaration ::= BaseVarDeclaration END
            {
              VarDeclarationNode RESULT =null;
		Name declaration = (Name)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
                RESULT = new VarDeclarationNode(declaration);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("VarDeclaration", 7, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 20: // VarDeclaration ::= VarInitDeclaration END
            {
              VarDeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
                RESULT = declaration;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("VarDeclaration", 7, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 21: // BaseVarDeclaration ::= Type IDENTIFIER
            {
              Name RESULT =null;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		String id = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = new Name(id, type);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("BaseVarDeclaration", 13, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 22: // VarInitDeclaration ::= BaseVarDeclaration ASSIGNMENT Expression
            {
              VarDeclarationNode RESULT =null;
		Name name = (Name)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-2)).value;
		ExpressionNode initialValue = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = new VarDeclarationNode(name, initialValue);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("VarInitDeclaration", 10, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 23: // GlobalConstDeclaration ::= CONST Type GLOBAL ASSIGNMENT Expression
            {
              VarDeclarationNode RESULT =null;
		Type type = (Type)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-3)).value;
		String id = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-2)).value;
		ExpressionNode initialValue = (ExpressionNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = new VarDeclarationNode(new Name(id, type), initialValue, true, true);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("GlobalConstDeclaration", 11, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 24: // LocalConstDeclaration ::= CONST VarInitDeclaration
            {
                VarDeclarationNode RESULT = null;
                VarDeclarationNode declaration = (VarDeclarationNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = declaration.constant();
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("LocalConstDeclaration", 12, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 25: // FunctionDeclaration ::= BaseVarDeclaration FunctionParameters BlockStatement
            {
                FunctionDeclarationNode RESULT = null;
                Name name = (Name) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 2)).value;
                List<Name> parameters = (List<Name>) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 1)).value;
                BlockStatementNode block = (BlockStatementNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = new FunctionDeclarationNode(name, parameters, block);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FunctionDeclaration", 14, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 26: // FunctionParameters ::= PARENTH_L PARENTH_R
            {
                List<Name> RESULT = null;
                RESULT = new ArrayList<>();
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FunctionParameters", 15, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 27: // FunctionParameters ::= PARENTH_L ParameterList PARENTH_R
            {
                List<Name> RESULT = null;
                List<Name> parameters = (List<Name>) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 1)).value;
                RESULT = parameters;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FunctionParameters", 15, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 28: // ParameterList ::= BaseVarDeclaration
            {
                List<Name> RESULT = null;
                Name parameter = (Name) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = new ArrayList<>(Collections.singletonList(parameter));
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ParameterList", 16, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 29: // ParameterList ::= ParameterList COMMA BaseVarDeclaration
            {
                List<Name> RESULT = null;
                List<Name> parameters = (List<Name>) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 2)).value;
                Name parameter = (Name) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                parameters.add(parameter);
                RESULT = parameters;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ParameterList", 16, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 30: // ClassDeclaration ::= CLASS TypeName ClassBlock
            {
              ClassDeclarationNode RESULT =null;
		String name = (String)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		DeclarationNode block = (DeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = new ClassDeclarationNode(name, block);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassDeclaration", 17, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 31: // ClassBlock ::= CURLY_L ClassElementList CURLY_R
            {
              DeclarationNode RESULT =null;
		DeclarationNode contents = (DeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
                RESULT = contents;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassBlock", 18, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 32: // ClassElementList ::= ClassElement ClassElementList
            {
              DeclarationNode RESULT =null;
		DeclarationNode element = (DeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		DeclarationNode elements = (DeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = element.linkedTo(elements);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassElementList", 19, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 33: // ClassElementList ::=
            {
              DeclarationNode RESULT =null;
                RESULT = null;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassElementList", 19, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 34: // ClassElement ::= VarConstDeclaration
            {
              DeclarationNode RESULT =null;
		VarDeclarationNode declaration = (VarDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = declaration;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassElement", 20, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 35: // ClassElement ::= ConstructorDeclaration
            {
              DeclarationNode RESULT =null;
		ConstructorDeclarationNode declaration = (ConstructorDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = declaration;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassElement", 20, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 36: // ClassElement ::= FunctionDeclaration
            {
              DeclarationNode RESULT =null;
		FunctionDeclarationNode declaration = (FunctionDeclarationNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = declaration;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ClassElement", 20, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 37: // ConstructorDeclaration ::= CONSTRUCTOR FunctionParameters BlockStatement
            {
              ConstructorDeclarationNode RESULT =null;
		List<Name> parameters = (List<Name>)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		BlockStatementNode block = (BlockStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = new ConstructorDeclarationNode(parameters, block);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstructorDeclaration", 21, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 38: // StatementList ::= Statement StatementList
            {
              StatementNode RESULT =null;
		StatementNode statement = (StatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
		StatementNode statements = (StatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = statement.linkedTo(statements);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("StatementList", 22, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 39: // StatementList ::=
            {
              StatementNode RESULT =null;
                RESULT = null;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("StatementList", 22, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 40: // Statement ::= VarDeclarationStatement
            {
              StatementNode RESULT =null;
		VarDeclarationStatementNode statement = (VarDeclarationStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = statement;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement", 23, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 41: // Statement ::= AssignmentStatement
            {
              StatementNode RESULT =null;
		AssignmentStatementNode statement = (AssignmentStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = statement;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement", 23, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 42: // Statement ::= FunctionCallStatement
            {
              StatementNode RESULT =null;
		FunctionCallStatementNode statement = (FunctionCallStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = statement;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement", 23, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 43: // Statement ::= ReturnStatement
            {
              StatementNode RESULT =null;
		ReturnStatementNode statement = (ReturnStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = statement;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement", 23, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 44: // Statement ::= IfElseStatement
            {
              StatementNode RESULT =null;
		IfElseStatementNode statement = (IfElseStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = statement;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement", 23, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 45: // Statement ::= SwitchStatement
            {
              StatementNode RESULT =null;
		SwitchStatementNode statement = (SwitchStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = statement;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement", 23, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 46: // Statement ::= WhileStatement
            {
              StatementNode RESULT =null;
		WhileStatementNode statement = (WhileStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = statement;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement", 23, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 47: // Statement ::= ForStatement
            {
              StatementNode RESULT =null;
		ForStatementNode statement = (ForStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = statement;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement", 23, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 48: // Statement ::= BlockStatement
            {
              StatementNode RESULT =null;
		BlockStatementNode statement = (BlockStatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = statement;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Statement", 23, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
            case 49: // BlockStatement ::= CURLY_L StatementList CURLY_R
            {
              BlockStatementNode RESULT =null;
		StatementNode root = (StatementNode)((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top-1)).value;
                RESULT = new BlockStatementNode(root);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("BlockStatement", 24, RESULT);
            }
          return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 50: // VarDeclarationStatement ::= VarConstDeclaration
            {
                VarDeclarationStatementNode RESULT = null;
                VarDeclarationNode declaration = (VarDeclarationNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = declaration.asStatement();
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("VarDeclarationStatement", 25, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 51: // AssignmentStatement ::= Designator ASSIGNMENT Expression END
            {
                AssignmentStatementNode RESULT = null;
                Designator designator = (Designator) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 3)).value;
                ExpressionNode expression = (ExpressionNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 1)).value;
                RESULT = new AssignmentStatementNode(designator, expression);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("AssignmentStatement", 26, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 52: // ReturnStatement ::= RETURN END
            {
                ReturnStatementNode RESULT = null;
                RESULT = new ReturnStatementNode();
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ReturnStatement", 30, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 53: // ReturnStatement ::= RETURN Expression END
            {
                ReturnStatementNode RESULT = null;
                ExpressionNode expression = (ExpressionNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 1)).value;
                RESULT = new ReturnStatementNode(expression);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ReturnStatement", 30, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 54: // IfElseStatement ::= IF Expression BlockStatement ElsePartStatement
            {
                IfElseStatementNode RESULT = null;
                ExpressionNode condition = (ExpressionNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 2)).value;
                BlockStatementNode ifBlock = (BlockStatementNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 1)).value;
                StatementNode elsePart = (StatementNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = new IfElseStatementNode(condition, ifBlock, elsePart);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("IfElseStatement", 31, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 55: // ElsePartStatement ::= ELSE BlockStatement
            {
                StatementNode RESULT = null;
                BlockStatementNode elseBlock = (BlockStatementNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = elseBlock;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ElsePartStatement", 32, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 56: // ElsePartStatement ::= ELSE IfElseStatement
            {
                StatementNode RESULT = null;
                IfElseStatementNode ifElse = (IfElseStatementNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = ifElse;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ElsePartStatement", 32, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 57: // ElsePartStatement ::=
            {
                StatementNode RESULT = null;
                RESULT = null;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ElsePartStatement", 32, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 58: // SwitchStatement ::= SWITCH Expression CURLY_L SwitchCasesStatement CURLY_R
            {
                SwitchStatementNode RESULT = null;
                ExpressionNode expression = (ExpressionNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 3)).value;
                Map<ExpressionNode, StatementNode> cases = (Map<ExpressionNode, StatementNode>) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 1)).value;
                RESULT = new SwitchStatementNode(expression, cases);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("SwitchStatement", 33, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 59: // SwitchCasesStatement ::= ConstantExpression ARROW Statement
            {
                Map<ExpressionNode, StatementNode> RESULT = null;
                ConstantExpressionNode expression = (ConstantExpressionNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 2)).value;
                StatementNode statement = (StatementNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = new HashMap<>(Collections.singletonMap(expression, statement));
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("SwitchCasesStatement", 34, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 60: // SwitchCasesStatement ::= SwitchCasesStatement Expression ARROW Statement
            {
                Map<ExpressionNode, StatementNode> RESULT = null;
                Map<ExpressionNode, StatementNode> cases = (Map<ExpressionNode, StatementNode>) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 3)).value;
                ExpressionNode expression = (ExpressionNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 2)).value;
                StatementNode statement = (StatementNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                cases.put(expression, statement);
                RESULT = cases;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("SwitchCasesStatement", 34, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 61: // WhileStatement ::= WHILE Expression BlockStatement
            {
                WhileStatementNode RESULT = null;
                ExpressionNode condition = (ExpressionNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 1)).value;
                BlockStatementNode whileBlock = (BlockStatementNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = new WhileStatementNode(condition, whileBlock);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("WhileStatement", 35, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 62: // ForStatement ::= FOR BaseVarDeclaration IN Expression BlockStatement
            {
                ForStatementNode RESULT = null;
                Name variable = (Name) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 3)).value;
                ExpressionNode iterable = (ExpressionNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 1)).value;
                BlockStatementNode forBlock = (BlockStatementNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = new ForStatementNode(variable, iterable, forBlock);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ForStatement", 36, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 63: // Expression ::= ConstantExpression
            {
                ExpressionNode RESULT = null;
                ConstantExpressionNode expression = (ConstantExpressionNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = expression;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Expression", 37, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 64: // Expression ::= ListConstructorExpression
            {
                ExpressionNode RESULT = null;
                ListConstructorExpressionNode expression = (ListConstructorExpressionNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = expression;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Expression", 37, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 65: // Expression ::= AnonymousObjectConstructorExpression
            {
                ExpressionNode RESULT = null;
                AnonymousObjectConstructorExpressionNode expression = (AnonymousObjectConstructorExpressionNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = expression;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Expression", 37, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 66: // ConstantExpression ::= INT
            {
                ConstantExpressionNode RESULT = null;
                String n = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = ConstantExpressionNode.fromInt(n);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression", 38, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 67: // ConstantExpression ::= REAL
            {
                ConstantExpressionNode RESULT = null;
                String x = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = ConstantExpressionNode.fromFloat(x);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression", 38, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 68: // ConstantExpression ::= TRUE
            {
                ConstantExpressionNode RESULT = null;
                String t = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = ConstantExpressionNode.fromBoolean(t);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression", 38, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 69: // ConstantExpression ::= FALSE
            {
                ConstantExpressionNode RESULT = null;
                String f = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = ConstantExpressionNode.fromBoolean(f);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression", 38, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 70: // ConstantExpression ::= CHAR
            {
                ConstantExpressionNode RESULT = null;
                String c = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = ConstantExpressionNode.fromChar(c);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression", 38, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 71: // ConstantExpression ::= NOTHING
            {
                ConstantExpressionNode RESULT = null;
                RESULT = ConstantExpressionNode.ofNothing();
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression", 38, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 72: // ConstantExpression ::= NULL
            {
                ConstantExpressionNode RESULT = null;
                RESULT = ConstantExpressionNode.ofNull();
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression", 38, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 73: // ConstantExpression ::= UNDERSCORE
            {
                ConstantExpressionNode RESULT = null;
                RESULT = ConstantExpressionNode.ofNull();
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ConstantExpression", 38, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 74: // ListConstructorExpression ::= STRING
            {
                ListConstructorExpressionNode RESULT = null;
                String str = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = ListConstructorExpressionNode.fromString(str);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ListConstructorExpression", 39, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 75: // ListConstructorExpression ::= SQUARE_L SQUARE_R
            {
                ListConstructorExpressionNode RESULT = null;
                RESULT = new ListConstructorExpressionNode();
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ListConstructorExpression", 39, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 76: // ListConstructorExpression ::= SQUARE_L ListElements SQUARE_R
            {
                ListConstructorExpressionNode RESULT = null;
                List<ExpressionNode> elements = (List<ExpressionNode>) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 1)).value;
                RESULT = new ListConstructorExpressionNode(elements);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ListConstructorExpression", 39, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 77: // ListElements ::= Expression
            {
                List<ExpressionNode> RESULT = null;
                ExpressionNode element = (ExpressionNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = new ArrayList<>(Collections.singletonList(element));
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ListElements", 40, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 78: // ListElements ::= ListElements COMMA Expression
            {
                List<ExpressionNode> RESULT = null;
                List<ExpressionNode> elements = (List<ExpressionNode>) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 2)).value;
                ExpressionNode element = (ExpressionNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                elements.add(element);
                RESULT = elements;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ListElements", 40, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 79: // AnonymousObjectConstructorExpression ::= CURLY_L CURLY_R
            {
                AnonymousObjectConstructorExpressionNode RESULT = null;
                RESULT = new AnonymousObjectConstructorExpressionNode();
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("AnonymousObjectConstructorExpression", 41, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 80: // AnonymousObjectConstructorExpression ::= CURLY_L AnonymousObjectFields CURLY_R
            {
                AnonymousObjectConstructorExpressionNode RESULT = null;
                VarDeclarationNode fields = (VarDeclarationNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 1)).value;
                RESULT = new AnonymousObjectConstructorExpressionNode(fields);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("AnonymousObjectConstructorExpression", 41, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 81: // AnonymousObjectFields ::= AnonymousObjectField
            {
                VarDeclarationNode RESULT = null;
                VarDeclarationNode field = (VarDeclarationNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = field;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("AnonymousObjectFields", 42, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 82: // AnonymousObjectFields ::= AnonymousObjectField COMMA AnonymousObjectFields
            {
                VarDeclarationNode RESULT = null;
                VarDeclarationNode field = (VarDeclarationNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 2)).value;
                VarDeclarationNode fields = (VarDeclarationNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                field.linkedTo(fields);
                RESULT = field;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("AnonymousObjectFields", 42, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 83: // AnonymousObjectField ::= VarInitDeclaration
            {
                VarDeclarationNode RESULT = null;
                VarDeclarationNode field = (VarDeclarationNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = field;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("AnonymousObjectField", 43, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 84: // AnonymousObjectField ::= LocalConstDeclaration
            {
                VarDeclarationNode RESULT = null;
                VarDeclarationNode field = (VarDeclarationNode) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = field;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("AnonymousObjectField", 43, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 85: // Type ::= TypeName
            {
                Type RESULT = null;
                String name = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = new Type(name);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Type", 45, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 86: // Type ::= TypeName LT Type GT
            {
                Type RESULT = null;
                String name = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 3)).value;
                Type param = (Type) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.elementAt(CUP$SyntacticalAnalyser$top - 1)).value;
                RESULT = new Type(name, param);
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Type", 45, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 87: // TypeName ::= TYPE
            {
                String RESULT = null;
                String name = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = name;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("TypeName", 44, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 88: // TypeName ::= GLOBAL
            {
                String RESULT = null;
                String name = (String) ((java_cup.runtime.Symbol) CUP$SyntacticalAnalyser$stack.peek()).value;
                RESULT = name;
                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("TypeName", 44, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 89: // Designator ::= IDENTIFIER
            {
                Designator RESULT = null;

                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Designator", 46, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 90: // Designator ::= ArrayAccess
            {
                Designator RESULT = null;

                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Designator", 46, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 91: // Designator ::= FieldAccess
            {
                Designator RESULT = null;

                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("Designator", 46, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 92: // ArrayAccess ::= DesignableExpression SQUARE_L Expression SQUARE_R
            {
                ExpressionNode RESULT = null;

                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("ArrayAccess", 47, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 93: // FieldAccess ::= DesignableExpression POINT IDENTIFIER
            {
                ExpressionNode RESULT = null;

                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("FieldAccess", 48, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 94: // DesignableExpression ::= IDENTIFIER
            {
                ExpressionNode RESULT = null;

                CUP$SyntacticalAnalyser$result = parser.getSymbolFactory().newSymbol("DesignableExpression", 49, RESULT);
            }
            return CUP$SyntacticalAnalyser$result;

            /* . . . . . .*/
            default:
                throw new Exception(
               "Invalid action number "+CUP$SyntacticalAnalyser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$SyntacticalAnalyser$do_action(
    int                        CUP$SyntacticalAnalyser$act_num,
    java_cup.runtime.lr_parser CUP$SyntacticalAnalyser$parser,
    java.util.Stack            CUP$SyntacticalAnalyser$stack,
    int                        CUP$SyntacticalAnalyser$top)
    throws java.lang.Exception
    {
              return CUP$SyntacticalAnalyser$do_action_part00000000(
                               CUP$SyntacticalAnalyser$act_num,
                               CUP$SyntacticalAnalyser$parser,
                               CUP$SyntacticalAnalyser$stack,
                               CUP$SyntacticalAnalyser$top);
    }
}

