package syntactical;

import java_cup.runtime.*;
import lexical.LexicalAnalyser;
import lexical.LexicalUnit;
import syntactical.ast.*;
import error.SyntacticalException;
import syntactical.OperatorOverloadConstants;

import java.util.*;

init with {::}
scan with {:
    return analyser.next_token();
:}
action code {::}
parser code {:
    private LexicalAnalyser analyser = (LexicalAnalyser) getScanner();
:}

terminal IF, ELSE, SWITCH, FOR, WHILE, IN, RETURN, CONST, CLASS, CONSTRUCTOR, UNDERSCORE, PARENTH_L, PARENTH_R,
         SQUARE_L, SQUARE_R, CURLY_L, CURLY_R, ARROW, ELLIPSIS, POINT, COMMA, PLUS_ASSIGN, PLUS, MINUS_ASSIGN, MINUS,
         MULT_ASSIGN, MULT, DIV_ASSIGN, DIV, MOD_ASSIGN, MOD, LE, LT, GE, GT, IDENTITY, EQUALS, NEQ, ASSIGNMENT, NOT,
         AND, OR, END;
terminal String IDENTIFIER, GLOBAL, THIS, TYPE, IMPORT;
terminal String INT, REAL, CHAR, STRING, TRUE, FALSE, NOTHING, NULL;

// Program
nonterminal ProgramNode Program;
// Imports
nonterminal List<String> ImportList;
nonterminal String Import, FilePath, Filename;
// Declarations
nonterminal DeclarationNode DeclarationList, Declaration;
// Variables
nonterminal VarDeclarationNode VarDeclaration, GlobalVarConstDeclaration, VarConstDeclaration, VarInitDeclaration,
            GlobalConstDeclaration, LocalConstDeclaration;
nonterminal Name BaseVarDeclaration;
// Functions
nonterminal FunctionDeclarationNode FunctionDeclaration;
nonterminal List<Name> FunctionParameters, ParameterList;
// Classes
nonterminal ClassDeclarationNode ClassDeclaration;
nonterminal DeclarationNode ClassBlock, ClassElementList, ClassElement;
nonterminal ConstructorDeclarationNode ConstructorDeclaration;
// Statements
nonterminal StatementNode StatementList, Statement;
// Block
nonterminal BlockStatementNode BlockStatement;
// Declaration statements
nonterminal VarDeclarationStatementNode VarDeclarationStatement;
// Assignment
nonterminal AssignmentStatementNode AssignmentStatement;
nonterminal Designator Designator;
// Function call
nonterminal FunctionCallStatementNode FunctionCallStatement;
// Return
nonterminal ReturnStatementNode ReturnStatement;
// Conditionals
nonterminal IfElseStatementNode IfElseStatement;
nonterminal StatementNode ElsePartStatement;
nonterminal SwitchStatementNode SwitchStatement;
nonterminal Map<ExpressionNode,StatementNode> SwitchCasesStatement;
// Loops
nonterminal WhileStatementNode WhileStatement;
nonterminal ForStatementNode ForStatement;
// Expressions
nonterminal ExpressionNode Expression;
nonterminal ExpressionNode Expression0;
nonterminal ExpressionNode Expression1;
nonterminal ExpressionNode Expression2;
nonterminal ExpressionNode Expression3;
nonterminal ExpressionNode Expression4;
nonterminal ExpressionNode Expression5;
nonterminal ExpressionNode Expression6;
nonterminal ExpressionNode Expression7;
nonterminal ExpressionNode Expression8;
nonterminal ExpressionNode Expression9;
nonterminal ExpressionNode InitialValueExpression;
nonterminal PointExpressionNode FieldAccessExpression;
nonterminal ArrayAccessExpressionNode ArrayAccessExpression;
nonterminal FunctionCallExpressionNode FunctionCallExpression;
// Constants
nonterminal VariableExpressionNode VariableExpression;
nonterminal ConstantExpressionNode ConstantExpression;
nonterminal ListConstructorExpressionNode ListConstructorExpression;
nonterminal List<ExpressionNode> ListElements;
nonterminal AnonymousObjectConstructorExpressionNode AnonymousObjectConstructorExpression;
nonterminal VarDeclarationNode AnonymousObjectFields, AnonymousObjectField;
nonterminal ConstructorCallExpressionNode ConstructorCallExpression;
// Other
nonterminal String TypeName;
nonterminal Type Type;
nonterminal List<ExpressionNode> Arguments, ArgumentList;

// TODO fix constructor conflicts

// Program
Program ::= ImportList: imports DeclarationList: declarations
            {: RESULT = new ProgramNode(declarations, imports); :};

// Imports
ImportList ::= ImportList: imports Import: file
               {: imports.add(file); RESULT = imports; :}
             |
               {: RESULT = new ArrayList<>(); :};
Import     ::= IMPORT FilePath: path END
               {: RESULT = path; :};
FilePath   ::= FilePath: path DIV Filename: filename
               {: RESULT = path + "/" + filename; :}
             | Filename: filename
               {: RESULT = filename; :};
Filename   ::= IDENTIFIER: name
               {: RESULT = name; :}
               | GLOBAL: name
               {: RESULT = name; :}
               | TYPE: name
               {: RESULT = name; :};

// Declarations
DeclarationList ::= Declaration: declaration DeclarationList: declarations
                    {: RESULT = declaration.linkedTo(declarations); :}
                  |
                    {: RESULT = null; :};
Declaration     ::= GlobalVarConstDeclaration: declaration
                    {: RESULT = declaration; :}
                  | FunctionDeclaration: declaration
                    {: RESULT = declaration; :}
                  | ClassDeclaration: declaration
                    {: RESULT = declaration; :};

// Variables
GlobalVarConstDeclaration ::= VarDeclaration: declaration
                              {: RESULT = declaration; :}
                            | GlobalConstDeclaration: declaration END
                              {: RESULT = declaration; :};
VarConstDeclaration       ::= VarDeclaration: declaration
                              {: RESULT = declaration; :}
                            | LocalConstDeclaration: declaration END
                              {: RESULT = declaration; :};
VarDeclaration            ::= BaseVarDeclaration: declaration END
                              {: RESULT = new VarDeclarationNode(declaration); :}
                            | VarInitDeclaration: declaration END
                              {: RESULT = declaration; :};
BaseVarDeclaration        ::= Type: type IDENTIFIER: id
                              {: RESULT = new Name(id, type); :};
VarInitDeclaration        ::= BaseVarDeclaration: name ASSIGNMENT InitialValueExpression: initialValue
                              {: RESULT = new VarDeclarationNode(name, initialValue); :}
                            | ConstructorCallExpression: constructor IDENTIFIER: id
                              {: RESULT = VarDeclarationNode.fromConstructor(constructor, id); :};
GlobalConstDeclaration    ::= CONST Type: type GLOBAL: id ASSIGNMENT InitialValueExpression: initialValue
                              {: RESULT = new VarDeclarationNode(new Name(id, type), initialValue, true); :}
                            | CONST ConstructorCallExpression: constructor GLOBAL: id
                              {: RESULT = VarDeclarationNode.fromConstructor(constructor, id).constant(); :};
LocalConstDeclaration     ::= CONST VarInitDeclaration: declaration
                              {: RESULT = declaration.constant(); :};
InitialValueExpression    ::= Expression: expression
                              {: RESULT = expression; :}
                            | AnonymousObjectConstructorExpression: expression
                              {: RESULT = expression; :};

// Functions
FunctionDeclaration ::= BaseVarDeclaration: name FunctionParameters: parameters BlockStatement: block
                        {: RESULT = new FunctionDeclarationNode(name, parameters, block); :};
FunctionParameters  ::= PARENTH_L PARENTH_R
                        {: RESULT = new ArrayList<>(); :}
                      | PARENTH_L ParameterList: parameters PARENTH_R
                        {: RESULT = parameters; :};
ParameterList       ::= BaseVarDeclaration: parameter
                        {: RESULT = new ArrayList<>(Collections.singletonList(parameter)); :}
                      | ParameterList: parameters COMMA BaseVarDeclaration: parameter
                        {: parameters.add(parameter); RESULT = parameters; :};

// Classes
ClassDeclaration       ::= CLASS TypeName: name ClassBlock: block
                           {: RESULT = new ClassDeclarationNode(name, block); :};
ClassBlock             ::= CURLY_L ClassElementList: contents CURLY_R
                           {: RESULT = contents; :};
ClassElementList       ::= ClassElement: element ClassElementList: elements
                           {: RESULT = element.linkedTo(elements); :}
                         |
                           {: RESULT = null; :};
ClassElement           ::= VarConstDeclaration: declaration
                           {: RESULT = declaration; :}
                         | ConstructorDeclaration: declaration
                           {: RESULT = declaration; :}
                         | FunctionDeclaration: declaration
                           {: RESULT = declaration; :};
ConstructorDeclaration ::= CONSTRUCTOR FunctionParameters: parameters BlockStatement: block
                           {: RESULT = new ConstructorDeclarationNode(parameters, block); :};

// Statements
StatementList ::= Statement: statement StatementList: statements
                  {: RESULT = statement.linkedTo(statements); :}
                |
                  {: RESULT = null; :};
Statement     ::= VarDeclarationStatement: statement
                  {: RESULT = statement; :}
                | AssignmentStatement: statement
                  {: RESULT = statement; :}
                | FunctionCallStatement: statement
                  {: RESULT = statement; :}
                | ReturnStatement: statement
                  {: RESULT = statement; :}
                | IfElseStatement: statement
                  {: RESULT = statement; :}
                | SwitchStatement: statement
                  {: RESULT = statement; :}
                | WhileStatement: statement
                  {: RESULT = statement; :}
                | ForStatement: statement
                  {: RESULT = statement; :}
                | BlockStatement: statement
                  {: RESULT = statement; :};

// Block
BlockStatement ::= CURLY_L StatementList: root CURLY_R
                   {: RESULT = new BlockStatementNode(root); :};

// Declaration statements
VarDeclarationStatement ::= VarConstDeclaration: declaration
                            {: RESULT = declaration.asStatement(); :};

// Assignment
AssignmentStatement ::= Designator: designator ASSIGNMENT Expression: expression END
                        {: RESULT = new AssignmentStatementNode(designator, expression); :}
                      | Designator: designator PLUS_ASSIGN Expression: expression END
                        {: RESULT = AssignmentStatementNode.fromSyntacticSugar(
                                            designator, OperatorOverloadConstants._PLUS, expression); :}
                      | Designator: designator MINUS_ASSIGN Expression: expression END
                        {: RESULT = AssignmentStatementNode.fromSyntacticSugar(
                                            designator, OperatorOverloadConstants._MINUS, expression); :}
                      | Designator: designator MULT_ASSIGN Expression: expression END
                        {: RESULT = AssignmentStatementNode.fromSyntacticSugar(
                                            designator, OperatorOverloadConstants._MULT, expression); :}
                      | Designator: designator DIV_ASSIGN Expression: expression END
                        {: RESULT = AssignmentStatementNode.fromSyntacticSugar(
                                            designator, OperatorOverloadConstants._DIV, expression); :}
                      | Designator: designator MOD_ASSIGN Expression: expression END
                        {: RESULT = AssignmentStatementNode.fromSyntacticSugar(
                                            designator, OperatorOverloadConstants._MOD, expression); :};

Designator   ::= VariableExpression: expression
                 {: RESULT = Designator.ofVar(expression); :}
               | FieldAccessExpression: expression
                 {: RESULT = Designator.ofField(expression); :}
               | ArrayAccessExpression: expression
                 {: RESULT = Designator.ofArray(expression); :};

// Function call
FunctionCallStatement ::= FunctionCallExpression: function END
                          {: RESULT = new FunctionCallStatementNode(function); :};

// Return
ReturnStatement ::= RETURN END
                    {: RESULT = new ReturnStatementNode(); :}
                  | RETURN Expression: expression END
                    {: RESULT = new ReturnStatementNode(expression); :};

// Conditionals
IfElseStatement   ::= IF Expression: condition BlockStatement: ifBlock ElsePartStatement: elsePart
                      {: RESULT = new IfElseStatementNode(condition, ifBlock, elsePart); :};
ElsePartStatement ::= ELSE BlockStatement: elseBlock
                      {: RESULT = elseBlock; :}
                    | ELSE IfElseStatement: ifElse
                      {: RESULT = ifElse; :}
                    |
                      {: RESULT = null; :};

SwitchStatement      ::= SWITCH Expression: expression CURLY_L SwitchCasesStatement: cases CURLY_R
                         {: RESULT = new SwitchStatementNode(expression, cases); :};
SwitchCasesStatement ::= ConstantExpression: expression ARROW Statement: statement
                         {: RESULT = new HashMap<>(Collections.singletonMap(expression, statement)); :}
                       | SwitchCasesStatement: cases Expression: expression ARROW Statement: statement
                         {: cases.put(expression, statement); RESULT = cases; :};

// Loops
WhileStatement ::= WHILE Expression: condition BlockStatement: whileBlock
                    {: RESULT = new WhileStatementNode(condition, whileBlock); :};

ForStatement ::= FOR BaseVarDeclaration: variable IN Expression: iterable BlockStatement: forBlock
                    {: RESULT = new ForStatementNode(variable, iterable, forBlock); :};


// Expressions
Expression ::= Expression0: expression
               {: RESULT = expression; :};

Expression0 ::= Expression0: first ELLIPSIS Expression1: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._TO, last); :}
              | Expression1: first
                {: RESULT = first; :};
Expression1 ::= Expression1: first OR Expression2: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._OR, last); :}
              | Expression2: first
                {: RESULT = first; :};
Expression2 ::= Expression2: first AND Expression3: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._AND, last); :}
              | Expression3: first
                {: RESULT = first; :};
Expression3 ::= Expression3: first EQUALS Expression4: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._EQUALS, last); :}
              | Expression3: first NEQ Expression4: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._NEQ, last); :}
              | Expression3: first IDENTITY Expression4: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._ID, last); :}
              | Expression4: first
                {: RESULT = first; :};
Expression4 ::= Expression4: first GT Expression5: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._GT, last); :}
              | Expression4: first GE Expression5: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._GE, last); :}
              | Expression4: first LT Expression5: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._LT, last); :}
              | Expression4: first LE Expression5: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._LE, last); :}
              | Expression5: first
                {: RESULT = first; :};
Expression5 ::= Expression5: first PLUS Expression6: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._PLUS, last); :}
              | Expression5: first MINUS Expression6: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._MINUS, last); :}
              | Expression6: first
                {: RESULT = first; :};
Expression6 ::= Expression6: first MULT Expression7: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._MULT, last); :}
              | Expression6: first DIV Expression7: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._DIV, last); :}
              | Expression6: first MOD Expression7: last
                {: RESULT = FunctionCallExpressionNode.operator(first, OperatorOverloadConstants._MOD, last); :}
              | Expression7: first
                {: RESULT = first; :};
Expression7 ::= PLUS Expression7: first
                {: RESULT = FunctionCallExpressionNode.operator(OperatorOverloadConstants._PLUS, first); :}
              | MINUS Expression7: first
                {: RESULT = FunctionCallExpressionNode.operator(OperatorOverloadConstants._MINUS, first); :}
              | NOT Expression7: first
                {: RESULT = FunctionCallExpressionNode.operator(OperatorOverloadConstants._NOT, first); :}
              | Expression8: first
                {: RESULT = first; :};
Expression8 ::= FieldAccessExpression: expression
                {: RESULT = expression; :}
              | ArrayAccessExpression: expression
                {: RESULT = expression; :}
              | FunctionCallExpression: expression
                {: RESULT = expression; :}
              | Expression9: expression
                {: RESULT = expression; :};
Expression9 ::= PARENTH_L Expression0: expression PARENTH_R
                {: RESULT = expression; :}
              | VariableExpression: expression
                {: RESULT = expression; :}
              | ConstantExpression: expression
                {: RESULT = expression; :}
              | ListConstructorExpression: expression
                {: RESULT = expression; :}
              | ConstructorCallExpression: expression
                {: RESULT = expression; :};

ArrayAccessExpression  ::= Expression8: array SQUARE_L Expression: index SQUARE_R
                           {: RESULT = new ArrayAccessExpressionNode(array, index); :};
FieldAccessExpression  ::= Expression8: expression POINT IDENTIFIER: identifier
                           {: RESULT = new PointExpressionNode(expression, identifier); :};
FunctionCallExpression ::= Expression8: function Arguments: arguments
                           {: RESULT = new FunctionCallExpressionNode(function, arguments); :};

// Constants
VariableExpression ::= IDENTIFIER: id
                       {: RESULT = new VariableExpressionNode(id); :}
                     // TODO uncomment
                     //| GLOBAL: id
                     //  {: RESULT = new VariableExpressionNode(id); :}
                     | THIS: id
                       {: RESULT = new VariableExpressionNode(id); :};
ConstantExpression ::= INT: n
                       {: RESULT = ConstantExpressionNode.fromInt(n); :}
                     | REAL: x
                       {: RESULT = ConstantExpressionNode.fromFloat(x); :}
                     | TRUE: t
                       {: RESULT = ConstantExpressionNode.fromBoolean(t); :}
                     | FALSE: f
                       {: RESULT = ConstantExpressionNode.fromBoolean(f); :}
                     | CHAR: c
                       {: RESULT = ConstantExpressionNode.fromChar(c); :}
                     | NOTHING
                       {: RESULT = ConstantExpressionNode.ofNothing(); :}
                     | NULL
                       {: RESULT = ConstantExpressionNode.ofNull(); :}
                     | UNDERSCORE
                       {: RESULT = ConstantExpressionNode.ofNull(); :};

ListConstructorExpression ::= STRING: str
                              {: RESULT = ListConstructorExpressionNode.fromString(str); :}
                            | SQUARE_L SQUARE_R
                              {: RESULT = new ListConstructorExpressionNode(); :}
                            | SQUARE_L ListElements: elements SQUARE_R
                              {: RESULT = new ListConstructorExpressionNode(elements); :};
ListElements              ::= Expression: element
                              {: RESULT = new ArrayList<>(Collections.singletonList(element)); :}
                            | ListElements: elements COMMA Expression: element
                              {: elements.add(element); RESULT = elements; :};

AnonymousObjectConstructorExpression ::= CURLY_L CURLY_R
                                         {: RESULT = new AnonymousObjectConstructorExpressionNode(); :}
                                       | CURLY_L AnonymousObjectFields: fields CURLY_R
                                         {: RESULT = new AnonymousObjectConstructorExpressionNode(fields); :};
AnonymousObjectFields                ::= AnonymousObjectField: field
                                         {: RESULT = field; :}
                                       | AnonymousObjectField: field COMMA AnonymousObjectFields: fields
                                         {: field.linkedTo(fields); RESULT = field; :};
AnonymousObjectField                 ::= VarInitDeclaration: field
                                         {: RESULT = field; :}
                                       | LocalConstDeclaration: field
                                         {: RESULT = field; :};

ConstructorCallExpression ::= Type: type Arguments: arguments
                              {: RESULT = new ConstructorCallExpressionNode(type, arguments); :};

// Other
Type     ::= TypeName: name
             {: RESULT = new Type(name); :}
           | TypeName: name LT Type: param GT
             {: RESULT = new Type(name, param); :};
TypeName ::= TYPE: name
             {: RESULT = name; :}
           | GLOBAL: name
             {: RESULT = name; :};

Arguments    ::= PARENTH_L PARENTH_R
                 {: RESULT = new ArrayList<>(); :}
               | PARENTH_L ArgumentList: arguments PARENTH_R
                 {: RESULT = arguments; :};
ArgumentList ::= Expression: argument
                 {: RESULT = new ArrayList<>(Collections.singletonList(argument)); :}
               | ArgumentList: arguments COMMA Expression: argument
                 {: arguments.add(argument); RESULT = arguments; :};